{
  "README.html": {
    "href": "README.html",
    "title": "Orleans.StateMachineES Documentation | Orleans.StateMachineES",
    "summary": "Orleans.StateMachineES Documentation This directory contains the DocFx-based documentation for Orleans.StateMachineES, including API reference and comprehensive guides. Building Documentation Locally Prerequisites .NET 9.0 SDK DocFx tool Install DocFx dotnet tool install -g docfx Build Documentation cd docfx docfx docfx.json The generated documentation will be in _site/ directory. Preview Documentation docfx docfx.json --serve Then open http://localhost:8080 in your browser. Documentation Structure docfx/ ├── docfx.json # Main configuration ├── filterConfig.yml # API filtering rules ├── toc.yml # Main table of contents ├── index.md # Landing page ├── api/ # Auto-generated API docs │ └── index.md ├── articles/ # Guides and tutorials │ ├── getting-started/ │ │ ├── index.md │ │ ├── installation.md │ │ ├── first-state-machine.md │ │ └── core-concepts.md │ ├── guides/ │ │ ├── index.md │ │ ├── async-patterns.md │ │ ├── analyzers.md │ │ └── ... │ ├── examples/ │ │ ├── index.md │ │ └── ... │ ├── architecture/ │ │ ├── index.md │ │ ├── performance.md │ │ └── ... │ └── reference/ │ ├── cheat-sheet.md │ └── ... ├── templates/ # Custom template │ └── custom/ │ └── public/ │ └── main.css └── images/ # Images and diagrams Content Guidelines Writing Articles Use GitHub-flavored Markdown Include code examples with proper syntax highlighting Link to API reference using relative paths Add cross-references between related topics Code Examples Use triple backticks with language identifier: ```csharp public class Example : StateMachineGrain<State, Trigger> { // Your code here } ``` Cross-References Reference API members: Classes: [StateMachineGrain](xref:Orleans.StateMachineES.StateMachineGrain-2) Methods: [FireAsync](xref:Orleans.StateMachineES.StateMachineGrain-2.FireAsync*) Reference articles: [Getting Started](../getting-started/index.md) [Async Patterns](../guides/async-patterns.md) Admonitions Use blockquotes with emoji for notes: > **Note**: This is important information. > **Warning**: This requires attention. > **Tip**: Helpful advice. Customization Theme The documentation uses the modern DocFx template with custom CSS in templates/custom/public/main.css. To modify: Edit main.css for styling changes Update docfx.json globalMetadata for site-wide settings Logo Place your logo at images/logo.svg and update docfx.json: \"fileMetadata\": { \"_appLogoPath\": { \"**/*\": \"images/logo.svg\" } } GitHub Pages Deployment Documentation is automatically built and deployed to GitHub Pages on every push to main branch via .github/workflows/docs.yml. Manual Deployment # Build documentation docfx docfx.json # Deploy to gh-pages branch cd _site git init git add . git commit -m \"Update documentation\" git push -f https://github.com/mivertowski/Orleans.StateMachineES.git main:gh-pages Troubleshooting Build Errors Issue: \"Project file not found\" # Ensure you're building from the solution root first cd .. dotnet build cd docfx docfx docfx.json Issue: \"Cannot find XML documentation\" # Enable XML documentation in project files # Add to each .csproj: <PropertyGroup> <GenerateDocumentationFile>true</GenerateDocumentationFile> </PropertyGroup> Missing Content Issue: Articles not showing in navigation Check: Article is listed in appropriate toc.yml Front matter is correct File path matches toc.yml reference Issue: API reference is empty Check: XML comments exist in source code GenerateDocumentationFile is enabled filterConfig.yml isn't excluding too much Contributing When adding new documentation: Create the article in the appropriate section Add to the section's toc.yml Cross-link from related articles Include code examples Build locally to verify Submit pull request Resources DocFx Documentation Markdown Guide GitHub Pages"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Reference | Orleans.StateMachineES",
    "summary": "API Reference This section contains the complete API documentation for Orleans.StateMachineES, automatically generated from XML documentation comments in the source code. Packages Orleans.StateMachineES The main library containing state machine grain implementations, event sourcing, advanced features, and production components. Key Namespaces: Orleans.StateMachineES - Core state machine grain base classes Orleans.StateMachineES.EventSourcing - Event sourcing support with state replay Orleans.StateMachineES.Hierarchical - Nested state hierarchies Orleans.StateMachineES.Sagas - Distributed saga patterns Orleans.StateMachineES.Timers - Timer and reminder management Orleans.StateMachineES.Tracing - OpenTelemetry distributed tracing Orleans.StateMachineES.Visualization - State diagram generation (DOT, Mermaid, PlantUML, HTML) Orleans.StateMachineES.Versioning - State machine versioning and migration Orleans.StateMachineES.Composition - Composable state machine patterns Orleans.StateMachineES.Composition.Components - Built-in components (CircuitBreaker, Retry, Validation, Approval) Orleans.StateMachineES.Orthogonal - Parallel state regions Orleans.StateMachineES.Memory - Performance optimizations (TriggerParameterCache, ObjectPools) Orleans.StateMachineES.Abstractions Core interfaces, models, and abstractions used across the library. Key Namespaces: Orleans.StateMachineES.Interfaces - Core grain interfaces (IStateMachineGrain, IEventSourcedStateMachineGrain) Orleans.StateMachineES.Models - Data models and metadata structures Orleans.StateMachineES.Generators Roslyn analyzers and source generators for compile-time safety and code generation. Key Components: 10 Roslyn Analyzers (OSMES001-010) - Compile-time safety checks Source Generator - YAML/JSON to state machine code generation Quick Links Getting Started: See First State Machine Core Concepts: See Core Concepts Guide Analyzer Reference: See Analyzer Guide Examples: See Examples Overview Searching the API Use the search box in the top navigation to quickly find classes, methods, properties, and other API members across all packages. Common Entry Points If you're new to the API, start with these key types: StateMachineGrain<TState, TTrigger> - Base class for basic state machine grains EventSourcedStateMachineGrain<TState, TTrigger> - Base class for event-sourced state machines IStateMachineGrain<TState, TTrigger> - Core interface for state machine operations CircuitBreakerComponent - Production resilience pattern for state machines StateMachineVisualization - Generate visual diagrams of your state machines Need Help? Guides: Browse the Guides section for detailed tutorials Examples: Check out complete examples with working code Troubleshooting: See the troubleshooting guide Issues: Report issues on GitHub"
  },
  "articles/architecture/design-decisions.html": {
    "href": "articles/architecture/design-decisions.html",
    "title": "design-decisions | Orleans.StateMachineES",
    "summary": "design-decisions Architecture documentation coming soon. See the Architecture Overview for details."
  },
  "articles/architecture/index.html": {
    "href": "articles/architecture/index.html",
    "title": "Architecture | Orleans.StateMachineES",
    "summary": "Architecture Deep dive into Orleans.StateMachineES design, implementation, and best practices for production deployments. Overview Orleans.StateMachineES is built on three foundational technologies: Microsoft Orleans - Distributed actor framework Stateless - Hierarchical state machine library .NET 9.0 - Modern runtime with performance optimizations This section explores architectural decisions, performance characteristics, and production deployment strategies. Architecture Topics Design Decisions Why Orleans.StateMachineES is designed the way it is. Topics covered: Orleans integration strategy Async operation patterns Event sourcing architecture Analyzer infrastructure Component composition model Performance Architecture How Orleans.StateMachineES achieves high performance. Key discoveries: Event sourcing is 30.4% faster than regular grains TriggerParameterCache provides ~100x speedup FrozenCollections offer 40%+ faster lookups ObjectPool optimization patterns ValueTask zero-allocation paths Performance metrics: Event-sourced: 5,923 transitions/sec (0.17ms latency) Regular: 4,123 transitions/sec (0.24ms latency) Parameterized triggers: 100x faster with caching Production Deployment Running Orleans.StateMachineES in production. Topics covered: Silo configuration and clustering Storage provider selection Monitoring and observability Circuit breaker patterns Error handling strategies High availability setup Performance tuning Capacity planning Security Considerations Security best practices and threat modeling. Topics covered: Grain isolation and authorization State persistence security Event sourcing audit trails Input validation Dependency security Network security Compliance considerations Testing Strategy Comprehensive testing approach. Topics covered: Unit testing state machines Integration testing with TestCluster Testing timers and reminders Testing event sourcing replay Testing hierarchical states Testing distributed sagas Performance testing Chaos engineering Scalability Patterns Scaling state machines to millions of grains. Topics covered: Horizontal scaling strategies Grain placement optimization State partitioning Stream processing at scale Performance under load Resource management Design Principles 1. Orleans-First Design Orleans.StateMachineES embraces Orleans patterns: Grain lifecycle integration Async-native APIs Stream support Event sourcing with JournaledGrain Distributed tracing 2. Compile-Time Safety 10 Roslyn analyzers catch issues before runtime: Async lambda detection (OSMES001) FireAsync in callback prevention (OSMES002) Missing configuration detection (OSMES003, OSMES009) Design quality checks (OSMES004-008, OSMES010) 3. Performance by Default Optimizations built in: Automatic trigger parameter caching Thread-safe object pooling FrozenCollections for immutable lookup ValueTask for synchronous paths Event sourcing with AutoConfirmEvents 4. Production Ready Battle-tested components: Circuit breaker pattern Retry components Validation components Health checks Distributed tracing Comprehensive error handling Component Architecture ┌─────────────────────────────────────────────────────────┐ │ Your Grain │ │ ┌──────────────────────────────────────────────────┐ │ │ │ StateMachineGrain<TState, TTrigger> │ │ │ │ │ │ │ │ ┌──────────────────────────────────────────┐ │ │ │ │ │ Stateless State Machine │ │ │ │ │ │ - State configuration │ │ │ │ │ │ - Trigger handling │ │ │ │ │ │ - Guard conditions │ │ │ │ │ └──────────────────────────────────────────┘ │ │ │ │ │ │ │ │ ┌──────────────────────────────────────────┐ │ │ │ │ │ TriggerParameterCache │ │ │ │ │ │ - 100x performance improvement │ │ │ │ │ └──────────────────────────────────────────┘ │ │ │ │ │ │ │ │ ┌──────────────────────────────────────────┐ │ │ │ │ │ Composition Components (Optional) │ │ │ │ │ │ - CircuitBreakerComponent │ │ │ │ │ │ - RetryComponent │ │ │ │ │ │ - ValidationComponent │ │ │ │ │ └──────────────────────────────────────────┘ │ │ │ └──────────────────────────────────────────────────┘ │ └─────────────────────────────────────────────────────────┘ ↓ ↓ ↓ ┌────────────────┐ ┌──────────────────┐ ┌─────────────┐ │ Orleans Grain │ │ Event Sourcing │ │ Distributed │ │ Storage │ │ (JournaledGrain) │ │ Tracing │ └────────────────┘ └──────────────────┘ └─────────────┘ Technology Stack Core Dependencies Microsoft.Orleans.Sdk 9.1.2 - Orleans actor framework Stateless 5.17.0 - State machine library .NET 9.0 - Target framework Optional Dependencies OpenTelemetry - Distributed tracing ASP.NET Core - Health checks System.Text.Json - Serialization Microsoft.Extensions.Logging - Logging Analyzer Dependencies Microsoft.CodeAnalysis - Roslyn analyzer infrastructure Microsoft.CodeAnalysis.CSharp - C# syntax analysis Evolution and Roadmap Version History v1.0.0 - Initial release with core features v1.0.2 - Async safety, hierarchical states, sagas, versioning v1.0.3 - Performance optimizations, 10 analyzers, circuit breaker v1.0.4 - Event sourcing performance breakthrough, production enhancements Future Directions Additional visualization formats Enhanced saga patterns More built-in components Performance improvements Analyzer enhancements Best Practices Summary Design Keep states focused and meaningful Use hierarchical states for related behaviors Design for testability Enable nullable reference types Performance Use event sourcing with AutoConfirmEvents Enable TriggerParameterCache (automatic in base class) Configure appropriate snapshot intervals Use ValueTask where applicable Production Implement circuit breakers for external dependencies Configure health checks Enable distributed tracing Monitor state machine metrics Plan for version upgrades Testing Test state transitions comprehensively Verify guard conditions Test timeout behavior Validate event replay Performance test under load Additional Resources Production Deployment Guide Performance Tuning Security Best Practices API Reference Examples"
  },
  "articles/architecture/performance.html": {
    "href": "articles/architecture/performance.html",
    "title": "Performance Architecture | Orleans.StateMachineES",
    "summary": "Performance Architecture Orleans.StateMachineES is optimized for high-performance distributed state management. Performance Breakthrough: Event Sourcing is Faster Critical Discovery: Event sourcing is 30.4% faster than regular state machine grains when properly configured. Benchmark Results Method | Mean | Allocated ------------------------------- | --------- | --------- Event Sourced (AutoConfirm) | 0.169 ms | 2.1 KB Regular State Machine | 0.243 ms | 3.7 KB Throughput Comparison: Event Sourced: 5,923 transitions/sec Regular: 4,123 transitions/sec Performance Gain: +43.7% more throughput Why Event Sourcing is Faster AutoConfirmEvents eliminates double-write: With AutoConfirmEvents = true, events are confirmed immediately without waiting for journal confirmation Optimized persistence path: JournaledGrain uses optimized Orleans log storage Better caching: Event log keeps recent state in memory Reduced allocations: 43% less memory allocation per transition Critical Configuration protected override void ConfigureEventSourcing(EventSourcingOptions options) { options.AutoConfirmEvents = true; // Essential for performance! options.EnableSnapshots = true; options.SnapshotInterval = 100; } Warning: Without AutoConfirmEvents = true, event sourcing performance degrades significantly. Performance Optimizations 1. TriggerParameterCache (~100x Speedup) Problem: Stateless recreates TriggerWithParameters objects on every call. Solution: Cache trigger parameter objects for reuse. // Before: Every call creates new objects var trigger = StateMachine.SetTriggerParameters<string>(OrderTrigger.Process); await FireAsync(trigger, \"data\"); // Repeated calls = repeated allocations // After: Cached in base class (automatic!) public class OrderGrain : StateMachineGrain<OrderState, OrderTrigger> { // TriggerParameterCache is automatically available // Base class caches all parameterized triggers } Performance impact: ~100x faster for repeated parameterized trigger calls Zero allocation for cached triggers Thread-safe concurrent access Benchmark: Without cache: 1,234 ops/sec With cache: 123,456 ops/sec Speedup: 100x 2. FrozenCollections (40%+ Faster Lookups) For .NET 8+, immutable collections use FrozenDictionary and FrozenSet: // Automatically used in .NET 8+ private static readonly FrozenSet<OrderState> TerminalStates = new[] { OrderState.Completed, OrderState.Cancelled }.ToFrozenSet(); private static readonly FrozenDictionary<OrderState, string> StateDescriptions = new Dictionary<OrderState, string> { [OrderState.Pending] = \"Awaiting confirmation\", [OrderState.Processing] = \"Being fulfilled\" }.ToFrozenDictionary(); Performance: 40%+ faster lookups vs Dictionary Optimized for read-heavy workloads Perfect for state machine metadata 3. ObjectPool Optimization Thread-safe object pooling with atomic slot reservation: public sealed class ObjectPool<T> where T : class, new() { public T Get() { // Try to get from pool for (int i = 0; i < _maxPoolSize; i++) { var obj = Interlocked.Exchange(ref _pool[i], null); if (obj != null) return obj; } // Pool exhausted, create new return new T(); } public void Return(T obj) { // Atomic slot reservation with CompareExchange for (int i = 0; i < _maxPoolSize; i++) { if (Interlocked.CompareExchange(ref _pool[i], obj, null) == null) return; } } } Features: Thread-safe without locks No memory leaks under concurrency Configurable pool size Zero allocation for pooled objects 4. ValueTask for Synchronous Paths Use ValueTask<T> to avoid Task allocation when operations complete synchronously: public ValueTask<TState> GetStateAsync() { // Synchronous path - no Task allocation return new ValueTask<TState>(StateMachine.State); } public ValueTask<bool> CanFireAsync(TTrigger trigger) { // Guard check is synchronous return new ValueTask<bool>(StateMachine.CanFire(trigger)); } Impact: Zero allocations for synchronous queries Better CPU cache utilization Reduced GC pressure 5. Consolidated Validation Reduce code duplication with shared validation helpers: // Before: Duplicated 60+ times if (_isInCallback) throw new InvalidOperationException(\"FireAsync cannot be called...\"); // After: Single helper method protected void ValidateNotInCallback() { if (_isInCallback) throw new InvalidOperationException(\"FireAsync cannot be called...\"); } // Usage public async Task FireAsync(TTrigger trigger) { ValidateNotInCallback(); // ... rest of implementation } Benefits: Eliminated 60+ lines of duplication Consistent error messages Easier to maintain No performance impact Performance Monitoring Built-in Metrics Orleans.StateMachineES exposes metrics for monitoring: public class StateMachineMetrics { public long TotalTransitions { get; set; } public long FailedTransitions { get; set; } public TimeSpan AverageTransitionTime { get; set; } public Dictionary<TState, long> StateVisitCounts { get; set; } public Dictionary<TTrigger, long> TriggerFireCounts { get; set; } } OpenTelemetry Integration using var activity = ActivitySource.StartActivity(\"StateMachine.Transition\"); activity?.SetTag(\"state.from\", fromState); activity?.SetTag(\"state.to\", toState); activity?.SetTag(\"trigger\", trigger); activity?.SetTag(\"duration.ms\", duration.TotalMilliseconds); Health Checks services.AddHealthChecks() .AddCheck<StateMachineHealthCheck>(\"state-machines\"); public class StateMachineHealthCheck : IHealthCheck { public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context) { // Check state machine metrics var metrics = await GetMetricsAsync(); if (metrics.FailedTransitions > threshold) return HealthCheckResult.Unhealthy(\"High failure rate\"); return HealthCheckResult.Healthy(); } } Performance Best Practices 1. Enable Event Sourcing with AutoConfirm // ✅ Best: Event sourcing with AutoConfirm (30% faster!) public class OrderGrain : EventSourcedStateMachineGrain<OrderState, OrderTrigger, OrderGrainState> { protected override void ConfigureEventSourcing(EventSourcingOptions options) { options.AutoConfirmEvents = true; // Essential! options.EnableSnapshots = true; options.SnapshotInterval = 100; } } 2. Use Parameterized Triggers Efficiently // ✅ Good: Cached automatically in base class public async Task ProcessOrderAsync(string customerId, decimal amount) { await FireAsync(OrderTrigger.Process, customerId, amount); } // ❌ Bad: Recreating trigger every time (old pattern) var trigger = StateMachine.SetTriggerParameters<string, decimal>(OrderTrigger.Process); await FireAsync(trigger, customerId, amount); 3. Keep Guards Simple // ✅ Good: Simple, fast guard .PermitIf(trigger, nextState, () => _isValid) // ❌ Bad: Complex computation in guard .PermitIf(trigger, nextState, () => { // Expensive computation on every check return CalculateComplexBusinessRule(); }) // ✅ Better: Cache computed values private bool _cachedRuleResult; .PermitIf(trigger, nextState, () => _cachedRuleResult) 4. Optimize Callback Logic // ✅ Good: Minimal synchronous work .OnEntry(() => { _timestamp = DateTime.UtcNow; _logger.LogInformation(\"State entered\"); }) // ❌ Bad: Heavy computation in callback .OnEntry(() => { // Blocks state transition var result = ExpensiveCalculation(); SaveToMultipleSystems(result); }) // ✅ Better: Queue async work .OnEntry(() => { _pendingWork.Enqueue(() => ProcessAsync()); }) 5. Configure Snapshots Appropriately protected override void ConfigureEventSourcing(EventSourcingOptions options) { options.EnableSnapshots = true; // High frequency: snapshot more often options.SnapshotInterval = 50; // Every 50 events // Low frequency: snapshot less often options.SnapshotInterval = 500; // Every 500 events // Balance replay time vs snapshot storage } Benchmarking Running Benchmarks cd benchmarks/Orleans.StateMachineES.Benchmarks dotnet run -c Release Custom Benchmarks using BenchmarkDotNet.Attributes; [MemoryDiagnoser] [SimpleJob(warmupCount: 3, iterationCount: 5)] public class StateMachineBenchmarks { [Benchmark] public async Task EventSourcedTransition() { var grain = _cluster.Client.GetGrain<IEventSourcedOrderGrain>(\"test\"); await grain.FireAsync(OrderTrigger.Process); } [Benchmark] public async Task RegularTransition() { var grain = _cluster.Client.GetGrain<IOrderGrain>(\"test\"); await grain.FireAsync(OrderTrigger.Process); } } Capacity Planning Grain Density Orleans can handle millions of grains per silo: Grain Memory: ~1-2 KB baseline + state size Grains per GB: ~500,000 - 1,000,000 Example: 1M order grains with 1KB state each Memory: ~2 GB Silos needed: 1 (with headroom) Throughput Estimates Based on benchmarks: Single Grain: - Event sourced: 5,923 transitions/sec - Regular: 4,123 transitions/sec Silo (10k active grains): - Theoretical max: 59M transitions/sec (event sourced) - Practical sustained: 5-10M transitions/sec Cluster (10 silos): - Sustained throughput: 50-100M transitions/sec Storage Considerations // Event sourced grain storage growth Events per grain: 1,000 Event size: 200 bytes Storage per grain: 200 KB 1M grains = 200 GB event log // With snapshots (interval = 100) Snapshots per grain: 10 Snapshot size: 1 KB Total: 200 KB events + 10 KB snapshots = 210 KB per grain Optimization Checklist [ ] Enable AutoConfirmEvents for event sourced grains [ ] Use TriggerParameterCache (automatic in v1.0.3+) [ ] Configure appropriate snapshot intervals [ ] Keep callbacks synchronous and minimal [ ] Use ValueTask for synchronous operations [ ] Implement health checks [ ] Monitor metrics with OpenTelemetry [ ] Benchmark critical paths [ ] Plan capacity based on grain density [ ] Use FrozenCollections for immutable lookup tables Troubleshooting Performance Slow Transitions Symptom: Transitions taking > 10ms Diagnosis: var stopwatch = Stopwatch.StartNew(); await grain.FireAsync(trigger); stopwatch.Stop(); Console.WriteLine($\"Transition took {stopwatch.ElapsedMilliseconds}ms\"); Common causes: Complex guards evaluated on every check Heavy computation in callbacks Missing AutoConfirmEvents on event sourced grains Network latency to storage Large state size serialization High Memory Usage Symptom: GC pressure, frequent Gen2 collections Diagnosis: dotnet-counters monitor --process-id <pid> \\ System.Runtime[gen-0-gc-count,gen-1-gc-count,gen-2-gc-count] Common causes: No object pooling for frequently allocated objects Large event logs without snapshots Unbounded deduplication cache String allocations in hot paths Low Throughput Symptom: < 1000 transitions/sec per grain Diagnosis: var metrics = await grain.GetMetricsAsync(); Console.WriteLine($\"Avg transition time: {metrics.AverageTransitionTime.TotalMilliseconds}ms\"); Console.WriteLine($\"Total transitions: {metrics.TotalTransitions}\"); Common causes: Using regular grains instead of event sourced Not using AutoConfirmEvents Synchronous blocking in Orleans grain Inadequate silo resources Storage provider bottleneck Additional Resources Benchmarks Source Performance Showcase Example Production Deployment Guide Orleans Performance Documentation"
  },
  "articles/architecture/production.html": {
    "href": "articles/architecture/production.html",
    "title": "production | Orleans.StateMachineES",
    "summary": "production Architecture documentation coming soon. See the Architecture Overview for details."
  },
  "articles/architecture/scalability.html": {
    "href": "articles/architecture/scalability.html",
    "title": "scalability | Orleans.StateMachineES",
    "summary": "scalability Architecture documentation coming soon. See the Architecture Overview for details."
  },
  "articles/architecture/security.html": {
    "href": "articles/architecture/security.html",
    "title": "security | Orleans.StateMachineES",
    "summary": "security Architecture documentation coming soon. See the Architecture Overview for details."
  },
  "articles/architecture/testing.html": {
    "href": "articles/architecture/testing.html",
    "title": "testing | Orleans.StateMachineES",
    "summary": "testing Architecture documentation coming soon. See the Architecture Overview for details."
  },
  "articles/examples/document-approval.html": {
    "href": "articles/examples/document-approval.html",
    "title": "document-approval Example | Orleans.StateMachineES",
    "summary": "document-approval Example Example documentation coming soon. See examples/document-approval/README.md in the repository for details."
  },
  "articles/examples/ecommerce.html": {
    "href": "articles/examples/ecommerce.html",
    "title": "ecommerce Example | Orleans.StateMachineES",
    "summary": "ecommerce Example Example documentation coming soon. See examples/ecommerce/README.md in the repository for details."
  },
  "articles/examples/index.html": {
    "href": "articles/examples/index.html",
    "title": "Examples | Orleans.StateMachineES",
    "summary": "Examples Production-ready example applications demonstrating Orleans.StateMachineES features. Available Examples E-Commerce Workflow Complete order processing system with event sourcing, timers, and monitoring. Features: Event-sourced order state machine Payment integration Inventory management Automatic timeouts for abandoned orders Email notifications Distributed tracing Complexity: Intermediate Source: examples/ECommerceWorkflow/ Document Approval Multi-level approval workflow with hierarchical states and distributed sagas. Features: Hierarchical state machine (Draft → Review → Approval) Multi-stakeholder approval process Saga orchestration for cross-system updates Compensation logic for rollbacks Audit trail Complexity: Advanced Source: examples/DocumentApproval/ Monitoring Dashboard Health checks, metrics collection, and observability patterns. Features: ASP.NET Core health checks integration OpenTelemetry distributed tracing State machine visualization Real-time metrics with Prometheus Dashboard UI with state diagrams Complexity: Intermediate Source: examples/MonitoringDashboard/ Smart Home Automation Source generator demonstration with orthogonal regions. Features: YAML/JSON state machine definitions Roslyn source generator usage Orthogonal regions (Security, Climate, Energy, Presence) Cross-region synchronization Vacation mode automation Complexity: Advanced Source: examples/SmartHome/ Performance Showcase Benchmarks and performance optimization demonstrations. Features: TriggerParameterCache benchmarks (~100x speedup) Event sourcing vs regular grain performance ObjectPool optimization FrozenCollections usage ValueTask patterns Complexity: Beginner Source: examples/PerformanceShowcase/ Running the Examples Each example is a complete, runnable application. To run any example: cd examples/<ExampleName> dotnet restore dotnet run Example Structure All examples follow a consistent structure: ExampleName/ ├── ExampleName.csproj # Project file ├── README.md # Example-specific documentation ├── Program.cs # Silo configuration ├── Grains/ # State machine grain implementations ├── Interfaces/ # Grain interfaces ├── Models/ # State, trigger, and data models ├── Configuration/ # Example-specific configuration └── Tests/ # Unit and integration tests Learning Path Beginner: Start Here Performance Showcase - Basic patterns and performance benefits E-Commerce Workflow - Event sourcing and timers Intermediate: Level Up Monitoring Dashboard - Observability and health checks Document Approval - Hierarchical states Advanced: Master the Library Smart Home Automation - Source generator and orthogonal regions Common Patterns Demonstrated Event Sourcing See: E-Commerce Workflow, Document Approval public class OrderGrain : EventSourcedStateMachineGrain<OrderState, OrderTrigger, OrderGrainState> { protected override void ConfigureEventSourcing(EventSourcingOptions options) { options.AutoConfirmEvents = true; // Essential! options.EnableSnapshots = true; options.SnapshotInterval = 100; } } Timers & Timeouts See: E-Commerce Workflow RegisterStateTimeout(OrderState.Pending, ConfigureTimeout(OrderState.Pending) .After(TimeSpan.FromHours(24)) .TransitionTo(OrderTrigger.Cancel) .UseReminder() .Build()); Hierarchical States See: Document Approval machine.Configure(DocumentState.InReview) .SubstateOf(DocumentState.Active) .Permit(DocumentTrigger.Approve, DocumentState.Approved); Distributed Sagas See: Document Approval public class DocumentPublishingSaga : SagaOrchestratorGrain<DocumentData> { protected override void ConfigureSagaSteps() { AddStep(new PublishToWebStep()).WithRetry(3); AddStep(new NotifySubscribersStep()).WithRetry(2); AddStep(new ArchiveOriginalStep()).WithRetry(1); } } Orthogonal Regions See: Smart Home Automation DefineOrthogonalRegion(\"Security\", SecurityState.Disarmed, machine => { ... }); DefineOrthogonalRegion(\"Climate\", ClimateState.Off, machine => { ... }); DefineOrthogonalRegion(\"Energy\", EnergyState.Normal, machine => { ... }); Source Generator See: Smart Home Automation SmartLight.statemachine.yaml: name: SmartLight states: [Off, On, Dimmed] triggers: [TurnOn, TurnOff, Dim] transitions: - { from: Off, to: On, trigger: TurnOn } - { from: On, to: Dimmed, trigger: Dim } Testing Examples Each example includes comprehensive tests. Run tests with: cd examples/<ExampleName> dotnet test Test Coverage Unit tests for state transitions Integration tests with Orleans TestCluster Guard condition validation Timeout and reminder behavior Event sourcing replay scenarios Configuration Patterns Storage Configuration siloBuilder .AddMemoryGrainStorage(\"Default\") .AddLogStorageBasedLogConsistencyProvider(\"LogStorage\") .AddMemoryGrainStorage(\"PubSubStore\"); Stream Configuration siloBuilder .AddStreams(\"SMS\") .AddMemoryStreams(\"SMS\"); Tracing Configuration services.AddOpenTelemetry() .WithTracing(builder => builder .AddSource(\"Orleans.StateMachineES\") .AddJaegerExporter()); Troubleshooting Examples Build Issues # Clean and restore dotnet clean dotnet restore dotnet build Runtime Issues Check the example README for: Required dependencies Configuration settings Known limitations Common errors Contributing Examples Have a great example? Contributions are welcome! Follow the standard example structure Include comprehensive README Add unit and integration tests Document key concepts used Submit a pull request See Contributing Guide for details. Additional Resources Getting Started Tutorial Guides API Reference Troubleshooting"
  },
  "articles/examples/monitoring.html": {
    "href": "articles/examples/monitoring.html",
    "title": "monitoring Example | Orleans.StateMachineES",
    "summary": "monitoring Example Example documentation coming soon. See examples/monitoring/README.md in the repository for details."
  },
  "articles/examples/performance-showcase.html": {
    "href": "articles/examples/performance-showcase.html",
    "title": "performance-showcase Example | Orleans.StateMachineES",
    "summary": "performance-showcase Example Example documentation coming soon. See examples/performance-showcase/README.md in the repository for details."
  },
  "articles/examples/smart-home.html": {
    "href": "articles/examples/smart-home.html",
    "title": "smart-home Example | Orleans.StateMachineES",
    "summary": "smart-home Example Example documentation coming soon. See examples/smart-home/README.md in the repository for details."
  },
  "articles/getting-started/core-concepts.html": {
    "href": "articles/getting-started/core-concepts.html",
    "title": "Core Concepts | Orleans.StateMachineES",
    "summary": "Core Concepts Understanding the fundamental concepts of Orleans.StateMachineES is essential for building robust state machines. State Machines Fundamentals A state machine models a system that can be in exactly one state at a time, with defined transitions between states triggered by events. Components States - Possible conditions the system can be in Triggers - Events that cause transitions Transitions - Rules for moving between states Guards - Conditions that control whether transitions are allowed Callbacks - Actions executed during transitions States States represent distinct conditions or phases in your system's lifecycle. Defining States Use enums for type-safe state definitions: public enum OrderState { Draft, // Initial state Submitted, // Awaiting payment Processing, // Being fulfilled Shipped, // In transit Delivered, // Complete Cancelled // Terminated } State Properties Mutually Exclusive: A state machine can only be in one state at a time (except with orthogonal regions). Persistent: The current state persists across grain activations. Observable: You can always query the current state with GetStateAsync(). State Configuration Configure each state in BuildStateMachine(): StateMachine.Configure(OrderState.Processing) .Permit(OrderTrigger.Ship, OrderState.Shipped) .Permit(OrderTrigger.Cancel, OrderState.Cancelled) .OnEntry(() => StartFulfillmentProcess()) .OnExit(() => CleanupResources()); Triggers Triggers are events that cause state transitions. Defining Triggers Use enums for type-safe trigger definitions: public enum OrderTrigger { Submit, ConfirmPayment, Ship, Deliver, Cancel } Firing Triggers Execute transitions with FireAsync(): await orderGrain.FireAsync(OrderTrigger.Submit); Trigger Types Simple Triggers: No additional data await grain.FireAsync(OrderTrigger.Cancel); Parameterized Triggers: Pass data with the transition var trigger = StateMachine.SetTriggerParameters<string>(OrderTrigger.Ship); await grain.FireAsync(trigger, \"UPS123456789\"); See Parameterized Triggers for details. Transitions Transitions define how the state machine moves from one state to another. Permit Transitions Use .Permit() to allow a transition: StateMachine.Configure(OrderState.Submitted) .Permit(OrderTrigger.ConfirmPayment, OrderState.Processing); Conditional Transitions Use .PermitIf() with guard conditions: StateMachine.Configure(OrderState.Submitted) .PermitIf( OrderTrigger.ConfirmPayment, OrderState.Processing, () => _paymentReceived && _inventoryAvailable ); Self-Transitions Allow a state to transition to itself: StateMachine.Configure(OrderState.Processing) .PermitReentry(OrderTrigger.UpdateStatus); Ignore Triggers Ignore triggers without error: StateMachine.Configure(OrderState.Cancelled) .Ignore(OrderTrigger.Ship); // Silently ignored Guard Conditions Guards control whether a transition is allowed based on runtime conditions. Simple Guards StateMachine.Configure(OrderState.Draft) .PermitIf( OrderTrigger.Submit, OrderState.Submitted, () => _items.Count > 0 // Guard: must have items ); Multiple Guards All guards must pass for the transition to succeed: StateMachine.Configure(OrderState.Submitted) .PermitIf( OrderTrigger.ConfirmPayment, OrderState.Processing, () => _paymentReceived, () => _inventoryAvailable, () => _shippingAddressValid ); Unmet Guards Check guard status before firing: // Returns list of unmet guard descriptions var unmetGuards = await grain.CanFireWithUnmetGuardsAsync( OrderTrigger.ConfirmPayment ); if (unmetGuards.UnmetGuards.Any()) { Console.WriteLine(\"Cannot confirm payment:\"); foreach (var guard in unmetGuards.UnmetGuards) { Console.WriteLine($\" - {guard}\"); } } See Guard Conditions for advanced patterns. Callbacks Callbacks execute custom logic during state transitions. OnEntry Callbacks Execute when entering a state: StateMachine.Configure(OrderState.Processing) .OnEntry(() => { _processingStartTime = DateTime.UtcNow; NotifyWarehouse(); }); OnExit Callbacks Execute when leaving a state: StateMachine.Configure(OrderState.Processing) .OnExit(() => { _processingDuration = DateTime.UtcNow - _processingStartTime; RecordMetrics(); }); OnEntryFrom Callbacks Execute when entering from a specific trigger: StateMachine.Configure(OrderState.Cancelled) .OnEntryFrom(OrderTrigger.CancelByCustomer, () => { _cancellationReason = \"Customer requested\"; RefundPayment(); }) .OnEntryFrom(OrderTrigger.CancelBySystem, () => { _cancellationReason = \"Fraud detected\"; BlockCustomer(); }); OnExitFrom Callbacks Execute when leaving to a specific state: StateMachine.Configure(OrderState.Processing) .OnExitFrom(OrderState.Shipped, () => { GenerateTrackingNumber(); }); Callback Constraints Critical: Callbacks must be synchronous. Async operations are not supported. // ❌ Wrong: Async not supported .OnEntry(async () => await SendEmailAsync()) // ✅ Correct: Use timers for async work .OnEntry(() => RegisterTimer(_ => SendEmailAsync(), null, TimeSpan.Zero, TimeSpan.MaxValue)) See Async Patterns for handling async operations correctly. State Machine Lifecycle Activation When a grain activates, BuildStateMachine() is called to construct the state machine: public override async Task OnActivateAsync(CancellationToken cancellationToken) { await base.OnActivateAsync(cancellationToken); // State machine is now ready } State Persistence The current state is persisted automatically: Automatic: State survives grain deactivation Consistent: State is part of grain state storage Event-Sourced: Optional full history with EventSourcedStateMachineGrain Deactivation On deactivation, state is saved: public override async Task OnDeactivateAsync(DeactivationReason reason, CancellationToken cancellationToken) { // State is automatically persisted await base.OnDeactivateAsync(reason, cancellationToken); } State Machine Metadata Query state machine information at runtime: Current State var state = await grain.GetStateAsync(); Permitted Triggers var triggers = await grain.GetPermittedTriggersAsync(); // Returns: [OrderTrigger.Ship, OrderTrigger.Cancel] Can Fire Check bool canShip = await grain.CanFireAsync(OrderTrigger.Ship); Complete Info var info = await grain.GetStateMachineInfoAsync(); Console.WriteLine($\"Current: {info.State}\"); Console.WriteLine($\"Initial: {info.InitialState}\"); Console.WriteLine($\"All states: {string.Join(\", \", info.States)}\"); Console.WriteLine($\"All triggers: {string.Join(\", \", info.Triggers)}\"); State Diagrams Visualize your state machine: var dot = await grain.GetDotGraphAsync(); var mermaid = await grain.GetMermaidDiagramAsync(); var plantUml = await grain.GetPlantUmlDiagramAsync(); See Visualization Guide for details. Best Practices 1. Use Descriptive Names // ✅ Good: Clear intent public enum OrderState { Draft, Submitted, Processing, Shipped } public enum OrderTrigger { Submit, ConfirmPayment, Ship } // ❌ Bad: Unclear meaning public enum State { S1, S2, S3 } public enum Event { E1, E2 } 2. Define All Transitions // ✅ Good: All states configured StateMachine.Configure(OrderState.Draft) .Permit(OrderTrigger.Submit, OrderState.Submitted) .Permit(OrderTrigger.Cancel, OrderState.Cancelled); // ❌ Bad: Unreachable states StateMachine.Configure(OrderState.Draft) .Permit(OrderTrigger.Submit, OrderState.Submitted); // OrderState.Cancelled is unreachable! The OSMES004 analyzer detects unreachable states. 3. Handle All Triggers // ✅ Good: Define what happens with unexpected triggers StateMachine.OnUnhandledTrigger((state, trigger) => { _logger.LogWarning(\"Unexpected trigger {Trigger} in state {State}\", trigger, state); }); 4. Keep Guards Simple // ✅ Good: Simple, testable guard .PermitIf(trigger, nextState, () => _isValid) // ❌ Bad: Complex logic in guard .PermitIf(trigger, nextState, () => { // 50 lines of complex validation // Cyclomatic complexity > 10 }) The OSMES008 analyzer warns about complex guards. 5. Avoid Side Effects in Guards // ❌ Bad: Guard modifies state .PermitIf(trigger, nextState, () => { _counter++; // Side effect! return _counter > 5; }) // ✅ Good: Guard is pure .PermitIf(trigger, nextState, () => _counter > 5) Next Steps Parameterized Triggers - Pass data with transitions Guard Conditions - Advanced validation patterns Async Patterns - Handling async operations correctly Event Sourcing - Complete state history Additional Resources Stateless Library Docs - Underlying state machine library API Reference Examples"
  },
  "articles/getting-started/first-state-machine.html": {
    "href": "articles/getting-started/first-state-machine.html",
    "title": "Your First State Machine | Orleans.StateMachineES",
    "summary": "Your First State Machine This tutorial walks you through creating your first state machine grain step by step. What We're Building We'll create a simple light switch state machine with two states (On/Off) and one trigger (Toggle). This demonstrates the fundamentals without complexity. Step 1: Define States and Triggers Create enums for your states and triggers: public enum LightState { Off, On } public enum LightTrigger { Toggle } Tip: Use clear, descriptive names. States are typically nouns (Off, On), triggers are verbs (Toggle, Switch). Step 2: Define the Grain Interface Create an interface that extends IStateMachineGrain<TState, TTrigger>: using Orleans.StateMachineES.Interfaces; public interface ILightSwitchGrain : IStateMachineGrain<LightState, LightTrigger> { // Optional: Add custom grain methods here Task<int> GetToggleCountAsync(); } The base interface provides all standard state machine operations: FireAsync(trigger) - Execute a transition GetStateAsync() - Query current state CanFireAsync(trigger) - Check if transition is permitted GetPermittedTriggersAsync() - Get all valid triggers Step 3: Implement the Grain Create a grain class that extends StateMachineGrain<TState, TTrigger>: using Orleans.StateMachineES; public class LightSwitchGrain : StateMachineGrain<LightState, LightTrigger>, ILightSwitchGrain { private int _toggleCount = 0; protected override void BuildStateMachine() { // Configure the Off state StateMachine.Configure(LightState.Off) .Permit(LightTrigger.Toggle, LightState.On) .OnEntry(() => { Console.WriteLine(\"Light is now OFF\"); }); // Configure the On state StateMachine.Configure(LightState.On) .Permit(LightTrigger.Toggle, LightState.Off) .OnEntry(() => { Console.WriteLine(\"Light is now ON\"); _toggleCount++; }); // Set the initial state StateMachine.State = LightState.Off; } public Task<int> GetToggleCountAsync() { return Task.FromResult(_toggleCount); } } Understanding BuildStateMachine() The BuildStateMachine() method is called during grain activation. Here you: Configure each state using StateMachine.Configure(state) Define transitions with .Permit(trigger, destinationState) Add callbacks using .OnEntry() and .OnExit() Set initial state with StateMachine.State = ... Important: Callbacks must be synchronous. See Async Patterns for handling async operations. Step 4: Use the Grain In your client or another grain: // Get a reference to the grain var lightSwitch = grainFactory.GetGrain<ILightSwitchGrain>(0); // Check current state var currentState = await lightSwitch.GetStateAsync(); Console.WriteLine($\"Current state: {currentState}\"); // Output: Off // Toggle the light await lightSwitch.FireAsync(LightTrigger.Toggle); currentState = await lightSwitch.GetStateAsync(); Console.WriteLine($\"Current state: {currentState}\"); // Output: On // Toggle again await lightSwitch.FireAsync(LightTrigger.Toggle); currentState = await lightSwitch.GetStateAsync(); Console.WriteLine($\"Current state: {currentState}\"); // Output: Off // Check toggle count var count = await lightSwitch.GetToggleCountAsync(); Console.WriteLine($\"Toggled {count} times\"); // Output: Toggled 1 times Step 5: Query State Machine Metadata Orleans.StateMachineES provides rich metadata about your state machine: var lightSwitch = grainFactory.GetGrain<ILightSwitchGrain>(0); // Check if a trigger can fire bool canToggle = await lightSwitch.CanFireAsync(LightTrigger.Toggle); Console.WriteLine($\"Can toggle: {canToggle}\"); // Output: true // Get all permitted triggers var permittedTriggers = await lightSwitch.GetPermittedTriggersAsync(); Console.WriteLine($\"Permitted: {string.Join(\", \", permittedTriggers)}\"); // Output: Permitted: Toggle // Get detailed state machine info var info = await lightSwitch.GetStateMachineInfoAsync(); Console.WriteLine($\"Current: {info.State}\"); Console.WriteLine($\"Initial: {info.InitialState}\"); Console.WriteLine($\"States: {string.Join(\", \", info.States)}\"); Console.WriteLine($\"Triggers: {string.Join(\", \", info.Triggers)}\"); Complete Example Here's the complete code in one place: // States and Triggers public enum LightState { Off, On } public enum LightTrigger { Toggle } // Interface public interface ILightSwitchGrain : IStateMachineGrain<LightState, LightTrigger> { Task<int> GetToggleCountAsync(); } // Implementation public class LightSwitchGrain : StateMachineGrain<LightState, LightTrigger>, ILightSwitchGrain { private int _toggleCount = 0; protected override void BuildStateMachine() { StateMachine.Configure(LightState.Off) .Permit(LightTrigger.Toggle, LightState.On) .OnEntry(() => Console.WriteLine(\"Light OFF\")); StateMachine.Configure(LightState.On) .Permit(LightTrigger.Toggle, LightState.Off) .OnEntry(() => { Console.WriteLine(\"Light ON\"); _toggleCount++; }); StateMachine.State = LightState.Off; } public Task<int> GetToggleCountAsync() => Task.FromResult(_toggleCount); } // Usage var light = grainFactory.GetGrain<ILightSwitchGrain>(0); await light.FireAsync(LightTrigger.Toggle); // Turn on await light.FireAsync(LightTrigger.Toggle); // Turn off var count = await light.GetToggleCountAsync(); // 1 What You've Learned How to define states and triggers using enums Creating a grain interface extending IStateMachineGrain<,> Implementing StateMachineGrain<,> and BuildStateMachine() Configuring states with transitions and callbacks Using FireAsync() to execute transitions Querying state machine metadata Common Mistakes 1. Forgetting to Set Initial State // ❌ Wrong: No initial state protected override void BuildStateMachine() { StateMachine.Configure(LightState.Off) .Permit(LightTrigger.Toggle, LightState.On); } // ✅ Correct: Set initial state protected override void BuildStateMachine() { StateMachine.Configure(LightState.Off) .Permit(LightTrigger.Toggle, LightState.On); StateMachine.State = LightState.Off; // Required! } The OSMES009 analyzer will catch this at compile time. 2. Using Async Lambdas in Callbacks // ❌ Wrong: Async lambda not supported StateMachine.Configure(LightState.On) .OnEntry(async () => { await SomeAsyncOperation(); }); // ✅ Correct: Keep callbacks synchronous StateMachine.Configure(LightState.On) .OnEntry(() => { RegisterTimer(_ => SomeAsyncOperation(), null, TimeSpan.Zero, TimeSpan.FromSeconds(5)); }); The OSMES001 analyzer will warn you about this pattern. 3. Calling FireAsync in Callbacks // ❌ Wrong: FireAsync in callback causes runtime error StateMachine.Configure(LightState.On) .OnEntry(() => { _ = FireAsync(LightTrigger.SomeOtherTrigger); // Runtime error! }); // ✅ Correct: Fire triggers from grain methods public async Task TurnOnAndDoSomethingAsync() { await FireAsync(LightTrigger.Toggle); // Now do async work after the transition await PerformAsyncOperation(); } The OSMES002 analyzer prevents this at compile time. Next Steps Now that you've built your first state machine: Learn core concepts - Understand states, triggers, and transitions in depth Add parameterized triggers - Pass data with transitions Implement guard conditions - Validate transitions with business logic Additional Resources Async Patterns Guide - Critical reading for production code Analyzer Reference - Understanding all 10 analyzers API Reference - Complete API documentation Examples - Real-world implementations"
  },
  "articles/getting-started/guard-conditions.html": {
    "href": "articles/getting-started/guard-conditions.html",
    "title": "Guard Conditions | Orleans.StateMachineES",
    "summary": "Guard Conditions Control state transitions with business logic validation. Coming Soon This guide will cover: Implementing guard conditions Multiple guards on a single transition Querying unmet guards Best practices for guard complexity For now, see the Core Concepts for basics."
  },
  "articles/getting-started/index.html": {
    "href": "articles/getting-started/index.html",
    "title": "Getting Started with Orleans.StateMachineES | Orleans.StateMachineES",
    "summary": "Getting Started with Orleans.StateMachineES Welcome to Orleans.StateMachineES! This guide will help you get up and running with state machines in your Orleans applications. What You'll Learn This getting started series covers: Installation - Setting up Orleans.StateMachineES in your project First State Machine - Building your first state machine grain Core Concepts - Understanding states, triggers, and transitions Parameterized Triggers - Passing data with transitions Guard Conditions - Validating transitions with business logic Next Steps - Exploring advanced features Prerequisites Before you begin, ensure you have: .NET 9.0 SDK or later installed Basic Orleans knowledge - Understanding of grains and the Orleans runtime C# familiarity - Knowledge of async/await, generics, and enums An Orleans project - Either existing or newly created If you're new to Orleans, check out the official Orleans documentation first. Quick Overview Orleans.StateMachineES provides state machine functionality for Orleans grains through: Core Components StateMachineGrain<TState, TTrigger> - Base class for state machine grains EventSourcedStateMachineGrain<TState, TTrigger> - Event sourcing support IStateMachineGrain<TState, TTrigger> - Standard grain interface Key Features Orleans-native async APIs Compile-time safety with 10 Roslyn analyzers Event sourcing with state replay Production components (circuit breakers, retries) Performance optimizations (TriggerParameterCache) Learning Path Beginner (Start Here) Install the packages Create your first state machine Understand core concepts Intermediate Use parameterized triggers Add guard conditions Explore async patterns Advanced Enable event sourcing Build hierarchical states Implement distributed sagas Example: Order Processing Here's a preview of what you'll be able to build: public enum OrderState { Draft, Submitted, PaymentPending, PaymentConfirmed, Processing, Shipped, Delivered, Cancelled } public enum OrderTrigger { Submit, ConfirmPayment, Process, Ship, Deliver, Cancel } public class OrderGrain : StateMachineGrain<OrderState, OrderTrigger>, IOrderGrain { protected override void BuildStateMachine() { StateMachine.Configure(OrderState.Draft) .Permit(OrderTrigger.Submit, OrderState.Submitted) .Permit(OrderTrigger.Cancel, OrderState.Cancelled); StateMachine.Configure(OrderState.Submitted) .OnEntry(() => StartPaymentProcessing()) .Permit(OrderTrigger.ConfirmPayment, OrderState.PaymentConfirmed) .Permit(OrderTrigger.Cancel, OrderState.Cancelled); StateMachine.Configure(OrderState.PaymentConfirmed) .Permit(OrderTrigger.Process, OrderState.Processing); StateMachine.Configure(OrderState.Processing) .Permit(OrderTrigger.Ship, OrderState.Shipped); StateMachine.Configure(OrderState.Shipped) .Permit(OrderTrigger.Deliver, OrderState.Delivered); } private void StartPaymentProcessing() { // Payment gateway integration var paymentGrain = GrainFactory.GetGrain<IPaymentGrain>(this.GetPrimaryKeyLong()); RegisterTimer( _ => paymentGrain.CheckPaymentStatusAsync(), null, TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30) ); } } This state machine handles the complete order lifecycle with transitions, entry callbacks, and integration with other grains. Need Help? Examples: Check out complete examples API Reference: Browse the API documentation Troubleshooting: See common issues Community: Ask questions on GitHub Discussions Ready to Begin? Start with Installation →"
  },
  "articles/getting-started/installation.html": {
    "href": "articles/getting-started/installation.html",
    "title": "Installation | Orleans.StateMachineES",
    "summary": "Installation This guide walks you through installing Orleans.StateMachineES in your project. Package Overview Orleans.StateMachineES consists of three NuGet packages: Package Purpose Required Orleans.StateMachineES Main library with state machine grains Yes Orleans.StateMachineES.Abstractions Core interfaces (auto-included) Auto Orleans.StateMachineES.Generators Roslyn analyzers for compile-time safety Recommended Installation Methods Using .NET CLI (Recommended) # Install main library dotnet add package Orleans.StateMachineES # Install analyzers (recommended) dotnet add package Orleans.StateMachineES.Generators Using Package Manager Console Install-Package Orleans.StateMachineES Install-Package Orleans.StateMachineES.Generators Using Visual Studio Right-click your project in Solution Explorer Select Manage NuGet Packages Search for Orleans.StateMachineES Click Install on both packages Manual Package Reference Add to your .csproj file: <ItemGroup> <PackageReference Include=\"Orleans.StateMachineES\" Version=\"1.0.4\" /> <PackageReference Include=\"Orleans.StateMachineES.Generators\" Version=\"1.0.4\" /> </ItemGroup> Version Compatibility Orleans.StateMachineES .NET Version Orleans Version 1.0.x .NET 9.0+ 9.1.0+ Verify Installation After installation, verify the packages are correctly referenced: dotnet list package You should see: Project 'YourProject' has the following package references [net9.0]: Top-level Package Requested Resolved > Orleans.StateMachineES 1.0.4 1.0.4 > Orleans.StateMachineES.Generators 1.0.4 1.0.4 Analyzer Configuration The Roslyn analyzers are enabled by default. To configure them, add to your .editorconfig or .globalconfig: # Treat async lambda warnings as errors in production dotnet_diagnostic.OSMES001.severity = error # Customize severity for specific analyzers dotnet_diagnostic.OSMES004.severity = suggestion # Unreachable states dotnet_diagnostic.OSMES005.severity = none # Multiple entry callbacks See the Analyzers Guide for complete configuration options. Project Setup Basic Orleans Setup Ensure your Orleans silo is configured. In your Program.cs: var builder = Host.CreateDefaultBuilder(args) .UseOrleans(siloBuilder => { siloBuilder.UseLocalhostClustering(); // Add other Orleans configuration }); var host = builder.Build(); await host.RunAsync(); Enable Event Sourcing (Optional) If you plan to use event sourcing, configure a storage provider: siloBuilder.UseOrleans(siloBuilder => { siloBuilder.UseLocalhostClustering(); // Add storage for event sourcing siloBuilder.AddMemoryGrainStorage(\"EventStore\"); // Or use Azure Table Storage siloBuilder.AddAzureTableGrainStorage(\"EventStore\", options => { options.ConfigureTableServiceClient(\"UseDevelopmentStorage=true\"); }); }); Troubleshooting Missing Abstractions Package If you see errors about missing IStateMachineGrain<,>: dotnet restore dotnet build The Abstractions package should be automatically restored as a dependency. Analyzer Not Working If analyzer warnings don't appear: Clean and rebuild: dotnet clean dotnet build Check analyzer status in Visual Studio: Go to Dependencies → Analyzers → Orleans.StateMachineES.Generators Ensure analyzers are listed and not disabled Restart your IDE Version Conflicts If you encounter version conflicts with Orleans packages: # Check all package versions dotnet list package --include-transitive # Update all packages to compatible versions dotnet add package Microsoft.Orleans.Sdk --version 9.1.2 Next Steps Now that you have Orleans.StateMachineES installed: Create your first state machine → Learn core concepts Explore examples Additional Resources NuGet Package Page GitHub Repository Release Notes Migration Guide (for upgrading from older versions)"
  },
  "articles/getting-started/next-steps.html": {
    "href": "articles/getting-started/next-steps.html",
    "title": "Next Steps | Orleans.StateMachineES",
    "summary": "Next Steps Continue your Orleans.StateMachineES journey. Advanced Topics Ready to explore more? Check out: Event Sourcing - Complete state history and 30% better performance Hierarchical States - Parent-child state relationships Distributed Sagas - Multi-grain workflows with compensation Circuit Breaker - Production resilience patterns Examples See real-world implementations: E-Commerce Workflow - Order processing with timers and events Document Approval - Multi-level approval process Smart Home - Orthogonal regions and source generation Reference Materials Cheat Sheet - Quick reference for all features API Documentation - Complete API reference Async Patterns - Critical reading for production code"
  },
  "articles/getting-started/parameterized-triggers.html": {
    "href": "articles/getting-started/parameterized-triggers.html",
    "title": "Parameterized Triggers | Orleans.StateMachineES",
    "summary": "Parameterized Triggers Pass data with state transitions using parameterized triggers. Coming Soon This guide will cover: Setting up parameterized triggers Passing one, two, or three arguments Using TriggerParameterCache for performance Type safety and compile-time checking For now, see the Cheat Sheet for examples."
  },
  "articles/guides/analyzers.html": {
    "href": "articles/guides/analyzers.html",
    "title": "Orleans.StateMachineES Analyzers Documentation | Orleans.StateMachineES",
    "summary": "Orleans.StateMachineES Analyzers Documentation Overview Orleans.StateMachineES includes a comprehensive set of Roslyn analyzers that provide compile-time safety and guidance for common state machine patterns and pitfalls. These analyzers help developers avoid runtime errors and follow best practices when implementing state machines with Orleans. Available Analyzers OSMES001: Async Lambda in State Callback Severity: Warning Category: Usage Detects async lambdas in state callbacks (OnEntry, OnExit, OnEntryFrom, OnExitFrom) that won't be awaited due to Stateless library limitations. Problem Example Configure(State.Processing) .OnEntry(async () => await ProcessDataAsync()); // ⚠️ OSMES001 Solution Configure(State.Processing) .OnEntry(() => Console.WriteLine(\"Entered Processing\")); // Move async logic to grain method public async Task StartProcessingAsync() { await FireAsync(Trigger.Start); await ProcessDataAsync(); // Async work after transition } OSMES002: FireAsync Within Callback Severity: Error Category: Usage Detects FireAsync calls within state callbacks that can cause deadlocks or reentrancy issues. Problem Example Configure(State.Active) .OnEntry(() => { FireAsync(Trigger.Process).Wait(); // \uD83D\uDEAB OSMES002 }); Solution Configure(State.Active) .OnEntry(() => LogEntry(\"Active\")); // Trigger transitions from grain methods instead public async Task ProcessAsync() { await FireAsync(Trigger.Process); } OSMES003: Missing BuildStateMachine Implementation Severity: Error Category: Implementation Detects classes deriving from StateMachineGrain that don't properly implement BuildStateMachine. Problem Example public class MyStateMachine : StateMachineGrain<State, Trigger> { protected override void BuildStateMachine() { // Empty or missing implementation \uD83D\uDEAB OSMES003 } } Solution public class MyStateMachine : StateMachineGrain<State, Trigger> { protected override void BuildStateMachine() { Configure(State.Idle) .Permit(Trigger.Start, State.Active); Configure(State.Active) .Permit(Trigger.Stop, State.Idle); } } OSMES004: Unreachable State Severity: Warning Category: Design Detects states that have no incoming transitions and aren't the initial state. Problem Example protected override void BuildStateMachine() { Configure(State.Idle) .Permit(Trigger.Start, State.Active); Configure(State.Active) .Permit(Trigger.Stop, State.Idle); Configure(State.Orphaned) // ⚠️ OSMES004: No way to reach this state .OnEntry(() => Console.WriteLine(\"Never reached\")); } Solution protected override void BuildStateMachine() { Configure(State.Idle) .Permit(Trigger.Start, State.Active) .Permit(Trigger.Error, State.Orphaned); // Add transition Configure(State.Active) .Permit(Trigger.Stop, State.Idle); Configure(State.Orphaned) .OnEntry(() => Console.WriteLine(\"Error state\")); } OSMES005: Duplicate State Configuration Severity: Warning Category: Design Detects states that are configured multiple times in BuildStateMachine. Problem Example protected override void BuildStateMachine() { Configure(State.Active) .Permit(Trigger.Pause, State.Paused); // Later in the method... Configure(State.Active) // ⚠️ OSMES005: Duplicate configuration .OnEntry(() => Console.WriteLine(\"Active\")); } Solution protected override void BuildStateMachine() { // Combine all configuration for each state Configure(State.Active) .Permit(Trigger.Pause, State.Paused) .OnEntry(() => Console.WriteLine(\"Active\")); } Code Fix Providers AsyncLambdaCodeFixProvider Automatically converts async lambdas to synchronous callbacks and generates separate async methods. Before Fix: Configure(State.Processing) .OnEntry(async () => { await LoadDataAsync(); await ProcessAsync(); }); After Fix: Configure(State.Processing) .OnEntry(() => _ = OnProcessingEntryAsync()); private async Task OnProcessingEntryAsync() { await LoadDataAsync(); await ProcessAsync(); } Configuration Using .editorconfig You can customize analyzer severities in your .editorconfig file: [*.cs] # Treat async lambda warning as error dotnet_diagnostic.OSMES001.severity = error # Disable unreachable state warning for generated code [**/Generated/**.cs] dotnet_diagnostic.OSMES004.severity = none # Suppress duplicate configuration in tests [**/*Tests.cs] dotnet_diagnostic.OSMES005.severity = none Global Suppression For project-wide suppression, add to your project file: <PropertyGroup> <NoWarn>$(NoWarn);OSMES004;OSMES005</NoWarn> </PropertyGroup> Inline Suppression Suppress specific instances using pragmas: #pragma warning disable OSMES004 // Unreachable state Configure(State.Debug) .OnEntry(() => Console.WriteLine(\"Debug mode\")); #pragma warning restore OSMES004 Best Practices Enable All Analyzers: Keep all analyzers enabled during development to catch issues early. Configure Severities: Adjust severities based on your project needs: Use error for critical issues in production code Use warning for code quality issues Use none only for generated or test code Use Code Fixes: Take advantage of automatic code fixes when available to quickly resolve issues. Document Suppressions: When suppressing analyzer warnings, add comments explaining why: // Orphaned state used only in unit tests #pragma warning disable OSMES004 CI/CD Integration: Consider treating warnings as errors in CI/CD: <PropertyGroup Condition=\"'$(CI)' == 'true'\"> <TreatWarningsAsErrors>true</TreatWarningsAsErrors> </PropertyGroup> Troubleshooting Analyzer Not Working Ensure the analyzer package is referenced: <PackageReference Include=\"Orleans.StateMachineES.Generators\" Version=\"1.0.2\" /> Clean and rebuild the solution: dotnet clean dotnet build Check if analyzers are loaded: In Visual Studio: View → Other Windows → Syntax Visualizer In VS Code: Check Problems panel False Positives If you encounter false positives: Verify you're using the latest version of the analyzers Check if the code pattern is supported Report issues at: https://github.com/mivertowski/Orleans.StateMachineES/issues Performance Impact The analyzers are designed to have minimal impact on build performance: They run concurrently They use efficient pattern matching They skip generated code by default If you experience slow builds, you can temporarily disable analyzers: <PropertyGroup> <RunAnalyzers>false</RunAnalyzers> </PropertyGroup> Future Enhancements Planned analyzer improvements: Detection of infinite state loops Validation of trigger parameter types Performance hints for large state machines Integration with Orleans Dashboard Contributing To contribute new analyzers or improvements: Follow the existing analyzer patterns Include comprehensive tests Update documentation Add entries to AnalyzerReleases.Unshipped.md See CONTRIBUTING.md for more details."
  },
  "articles/guides/async-patterns.html": {
    "href": "articles/guides/async-patterns.html",
    "title": "Async Operations in Orleans.StateMachineES | Orleans.StateMachineES",
    "summary": "Async Operations in Orleans.StateMachineES Important: Understanding Stateless Limitations The underlying Stateless library does not support async operations in state callbacks (OnEntry, OnExit, OnEntryFrom, OnExitTo). This is a fundamental design limitation of Stateless, not Orleans.StateMachineES. ❌ Common Mistakes to Avoid 1. Don't Use Async Lambdas in Callbacks // ❌ WRONG - This will NOT work correctly machine.Configure(OrderState.Processing) .OnEntry(async () => { // This async operation will run as fire-and-forget! await SaveToDatabase(); // NOT AWAITED! await SendEmail(); // NOT AWAITED! }); // ❌ WRONG - Don't call FireAsync from callbacks machine.Configure(OrderState.Processing) .OnEntry(() => { // This will throw InvalidOperationException at runtime FireAsync(OrderTrigger.Complete).Wait(); // DEADLOCK or EXCEPTION! }); 2. Don't Block on Async Operations // ❌ WRONG - This will cause deadlocks machine.Configure(OrderState.Processing) .OnEntry(() => { SaveToDatabase().Wait(); // DEADLOCK! Task.Run(async () => await SendEmail()).Wait(); // DEADLOCK! }); ✅ Correct Patterns Pattern 1: Perform Async Operations in Grain Methods The recommended approach is to perform async operations in your grain methods, not in state callbacks: public class OrderGrain : StateMachineGrain<OrderState, OrderTrigger>, IOrderGrain { protected override StateMachine<OrderState, OrderTrigger> BuildStateMachine() { var machine = new StateMachine<OrderState, OrderTrigger>(OrderState.Created); // Configure states with SYNCHRONOUS callbacks only machine.Configure(OrderState.Created) .Permit(OrderTrigger.Submit, OrderState.Processing) .OnExit(() => LogTransition(\"Leaving Created state\")); // Synchronous logging machine.Configure(OrderState.Processing) .Permit(OrderTrigger.Complete, OrderState.Completed) .OnEntry(() => LogTransition(\"Entering Processing state\")) // Synchronous logging .OnExit(() => LogTransition(\"Leaving Processing state\")); return machine; } // Grain method that handles async operations public async Task SubmitOrderAsync(OrderData data) { // 1. Perform async operations BEFORE state transition await ValidateOrderAsync(data); await SaveToDatabase(data); // 2. Fire the trigger (state transition) await FireAsync(OrderTrigger.Submit); // 3. Perform async operations AFTER state transition await SendConfirmationEmailAsync(data); await NotifyInventoryServiceAsync(data); } private void LogTransition(string message) { // Synchronous logging is fine Console.WriteLine($\"[{DateTime.UtcNow}] {message}\"); } } Pattern 2: Use State Change Notifications If you need to react to state changes with async operations, use a separate method: public class OrderGrain : EventSourcedStateMachineGrain<OrderState, OrderTrigger, OrderGrainState>, IOrderGrain { private readonly Queue<Func<Task>> _postTransitionTasks = new(); protected override StateMachine<OrderState, OrderTrigger> BuildStateMachine() { var machine = new StateMachine<OrderState, OrderTrigger>(OrderState.Created); machine.Configure(OrderState.Processing) .Permit(OrderTrigger.Complete, OrderState.Completed) .OnEntry(() => { // Queue async work to be done after transition _postTransitionTasks.Enqueue(() => SendProcessingNotificationAsync()); }); return machine; } public override async Task FireAsync(OrderTrigger trigger) { // Fire the trigger await base.FireAsync(trigger); // Execute any queued async operations after transition while (_postTransitionTasks.Count > 0) { var task = _postTransitionTasks.Dequeue(); await task(); } } private async Task SendProcessingNotificationAsync() { await _notificationService.NotifyAsync(\"Order is being processed\"); } } Pattern 3: State-Specific Grain Methods Create grain methods that encapsulate both the state transition and related async operations: public interface IOrderGrain : IGrainWithStringKey { Task<OrderSubmissionResult> SubmitOrderAsync(OrderData data); Task<ProcessingResult> ProcessOrderAsync(); Task<CompletionResult> CompleteOrderAsync(); } public class OrderGrain : StateMachineGrain<OrderState, OrderTrigger>, IOrderGrain { public async Task<OrderSubmissionResult> SubmitOrderAsync(OrderData data) { // Validate current state if (!await CanFireAsync(OrderTrigger.Submit)) { return new OrderSubmissionResult { Success = false, Message = \"Order cannot be submitted in current state\" }; } // Perform async pre-transition operations var validationResult = await ValidateOrderAsync(data); if (!validationResult.IsValid) { return new OrderSubmissionResult { Success = false, Message = validationResult.Message }; } // State transition await FireAsync(OrderTrigger.Submit); // Perform async post-transition operations await SaveOrderAsync(data); await SendConfirmationEmailAsync(data); return new OrderSubmissionResult { Success = true, OrderId = this.GetPrimaryKeyString() }; } } Compile-Time Safety Orleans.StateMachineES includes Roslyn analyzers that detect common async mistakes at compile time: OSMES001: Async Lambda in Callback // This will generate a compiler warning machine.Configure(State.Active) .OnEntry(async () => await DoSomething()); // ⚠️ Warning OSMES001 OSMES002: FireAsync in Callback // This will generate a compiler error machine.Configure(State.Active) .OnEntry(() => { FireAsync(Trigger.Next); // ❌ Error OSMES002 }); Best Practices Keep callbacks simple and synchronous: Use them only for logging, metrics, or updating local state Perform async operations in grain methods: This gives you full control over error handling and ordering Validate before transitioning: Check if a trigger can fire before performing expensive operations Use event sourcing for reliability: EventSourcedStateMachineGrain handles async persistence automatically Document your state machine flow: Make it clear where async operations occur in your workflow Example: Complete Order Processing Workflow public class OrderProcessingGrain : EventSourcedStateMachineGrain<OrderState, OrderTrigger, OrderGrainState>, IOrderGrain { private readonly IOrderRepository _repository; private readonly IEmailService _emailService; private readonly IPaymentService _paymentService; public OrderProcessingGrain( IOrderRepository repository, IEmailService emailService, IPaymentService paymentService) { _repository = repository; _emailService = emailService; _paymentService = paymentService; } protected override StateMachine<OrderState, OrderTrigger> BuildStateMachine() { var machine = new StateMachine<OrderState, OrderTrigger>(() => State.CurrentState); machine.Configure(OrderState.Created) .Permit(OrderTrigger.Submit, OrderState.Validating); machine.Configure(OrderState.Validating) .Permit(OrderTrigger.Approve, OrderState.PaymentPending) .Permit(OrderTrigger.Reject, OrderState.Rejected); machine.Configure(OrderState.PaymentPending) .Permit(OrderTrigger.PaymentReceived, OrderState.Processing) .Permit(OrderTrigger.PaymentFailed, OrderState.PaymentFailed); machine.Configure(OrderState.Processing) .Permit(OrderTrigger.Ship, OrderState.Shipped) .Permit(OrderTrigger.Cancel, OrderState.Cancelled); machine.Configure(OrderState.Shipped) .Permit(OrderTrigger.Deliver, OrderState.Delivered); return machine; } public async Task<OrderResult> CreateOrderAsync(CreateOrderCommand command) { // Initialize state State.OrderId = command.OrderId; State.CustomerId = command.CustomerId; State.Items = command.Items; State.CurrentState = OrderState.Created; // Save to repository await _repository.CreateOrderAsync(State); // Send confirmation email await _emailService.SendOrderCreatedEmailAsync(State.CustomerId, State.OrderId); return new OrderResult { Success = true, OrderId = State.OrderId }; } public async Task<OrderResult> SubmitForValidationAsync() { // Check if we can transition if (!await CanFireAsync(OrderTrigger.Submit)) { return new OrderResult { Success = false, Message = $\"Cannot submit order in state {State.CurrentState}\" }; } // Transition to Validating await FireAsync(OrderTrigger.Submit); // Perform validation asynchronously var validationResult = await ValidateOrderAsync(); if (validationResult.IsValid) { await FireAsync(OrderTrigger.Approve); await _emailService.SendOrderApprovedEmailAsync(State.CustomerId, State.OrderId); // Initiate payment process var paymentResult = await _paymentService.ProcessPaymentAsync(State); if (paymentResult.Success) { await FireAsync(OrderTrigger.PaymentReceived); // Start processing await StartOrderProcessingAsync(); } else { await FireAsync(OrderTrigger.PaymentFailed); await _emailService.SendPaymentFailedEmailAsync(State.CustomerId, State.OrderId); } } else { await FireAsync(OrderTrigger.Reject); await _emailService.SendOrderRejectedEmailAsync( State.CustomerId, State.OrderId, validationResult.Reasons); } return new OrderResult { Success = true, OrderId = State.OrderId, State = State.CurrentState }; } private async Task<ValidationResult> ValidateOrderAsync() { // Async validation logic var inventoryCheck = await _repository.CheckInventoryAsync(State.Items); var creditCheck = await _paymentService.CheckCreditAsync(State.CustomerId); return new ValidationResult { IsValid = inventoryCheck && creditCheck, Reasons = GenerateValidationReasons(inventoryCheck, creditCheck) }; } private async Task StartOrderProcessingAsync() { // Queue for fulfillment await _repository.QueueForFulfillmentAsync(State.OrderId); // Notify warehouse await _emailService.NotifyWarehouseAsync(State.OrderId, State.Items); } } Summary Stateless callbacks are synchronous: This is by design and cannot be changed Use grain methods for async operations: This is the Orleans way Leverage compile-time analyzers: They'll catch common mistakes Follow the patterns: They ensure reliable and maintainable code Event sourcing handles persistence: You don't need async in callbacks for persistence Remember: The separation between synchronous state configuration and asynchronous execution logic is intentional and leads to cleaner, more maintainable code."
  },
  "articles/guides/circuit-breaker.html": {
    "href": "articles/guides/circuit-breaker.html",
    "title": "Circuit Breaker Pattern | Orleans.StateMachineES",
    "summary": "Circuit Breaker Pattern Production resilience for state machines. Coming Soon See the Cheat Sheet for examples."
  },
  "articles/guides/composition.html": {
    "href": "articles/guides/composition.html",
    "title": "State Machine Composition | Orleans.StateMachineES",
    "summary": "State Machine Composition Reusable components for common patterns. Coming Soon See the Cheat Sheet for examples."
  },
  "articles/guides/distributed-sagas.html": {
    "href": "articles/guides/distributed-sagas.html",
    "title": "Distributed Sagas | Orleans.StateMachineES",
    "summary": "Distributed Sagas Multi-grain workflows with automatic compensation. Coming Soon See the Cheat Sheet for examples."
  },
  "articles/guides/event-sourcing.html": {
    "href": "articles/guides/event-sourcing.html",
    "title": "Event Sourcing | Orleans.StateMachineES",
    "summary": "Event Sourcing Complete state history and replay with EventSourcedStateMachineGrain. Coming Soon Full guide coming soon. For now, see: Cheat Sheet - Event Sourcing Performance Guide - Event sourcing is 30% faster! API Reference"
  },
  "articles/guides/health-checks.html": {
    "href": "articles/guides/health-checks.html",
    "title": "Health Checks | Orleans.StateMachineES",
    "summary": "Health Checks ASP.NET Core health monitoring integration. Coming Soon See the Cheat Sheet for examples."
  },
  "articles/guides/hierarchical-states.html": {
    "href": "articles/guides/hierarchical-states.html",
    "title": "Hierarchical States | Orleans.StateMachineES",
    "summary": "Hierarchical States Parent-child state relationships with substates. Coming Soon Full guide coming soon. For now, see: Cheat Sheet - Hierarchical States API Reference"
  },
  "articles/guides/index.html": {
    "href": "articles/guides/index.html",
    "title": "Guides | Orleans.StateMachineES",
    "summary": "Guides Comprehensive guides for mastering Orleans.StateMachineES features and patterns. Core Guides Async Patterns Critical reading - Understanding async operations and Stateless library limitations. Learn the correct patterns for handling async operations in state machine grains, common mistakes to avoid, and compile-time safety with OSMES001 and OSMES002 analyzers. Roslyn Analyzers Complete guide to all 10 Roslyn analyzers for compile-time safety. Understand OSMES001-OSMES010, how to configure analyzer severities, use code fixes, and integrate analyzers into your CI/CD pipeline. Advanced Features Event Sourcing Enable complete state history with automatic persistence and replay. Performance discovery: Event sourcing is 30.4% faster than regular state machines when properly configured with AutoConfirmEvents = true. Hierarchical States Build parent-child state relationships with substates. Model complex state hierarchies, navigate state trees, and use inheritance patterns for cleaner state machine design. Distributed Sagas Implement multi-grain workflows with automatic compensation. Orchestrate complex business processes across multiple grains with automatic rollback, retry logic, and full audit trails. Orthogonal Regions Manage parallel independent state machines. Run multiple state machines concurrently within a single grain, perfect for systems with independent subsystems like smart home automation. Production Features Circuit Breaker Pattern Prevent cascading failures with built-in resilience. Configure failure thresholds, recovery strategies, and exception handling for production-grade reliability. Timers & Reminders State-driven timeouts and scheduled transitions. Choose between timers (short-lived) and reminders (persistent), configure timeouts, and handle expiration gracefully. Distributed Tracing OpenTelemetry integration for complete observability. Trace state transitions across distributed systems, correlate operations, and monitor state machine performance. State Visualization Generate diagrams from your state machines. Export state machines to DOT, Mermaid, PlantUML, and HTML formats for documentation and debugging. Patterns & Best Practices State Machine Composition Build reusable components for common patterns. Use ValidationComponent, RetryComponent, ApprovalComponent, and CircuitBreakerComponent to compose complex behaviors. State Versioning Manage state machine evolution across deployments. Handle version upgrades, backward compatibility, breaking changes, and migration strategies for long-running systems. Health Checks ASP.NET Core health monitoring integration. Monitor state machine health, expose health endpoints, and integrate with monitoring dashboards. Quick Navigation New to Orleans.StateMachineES? Start with Getting Started Looking for examples? Check out Examples Need API reference? Browse the API Documentation Production deployment? See Architecture"
  },
  "articles/guides/orthogonal-regions.html": {
    "href": "articles/guides/orthogonal-regions.html",
    "title": "Orthogonal Regions | Orleans.StateMachineES",
    "summary": "Orthogonal Regions Parallel independent state machines. Coming Soon See the Cheat Sheet for examples."
  },
  "articles/guides/timers.html": {
    "href": "articles/guides/timers.html",
    "title": "Timers & Reminders | Orleans.StateMachineES",
    "summary": "Timers & Reminders State-driven timeouts and scheduled transitions. Coming Soon See the Cheat Sheet for examples."
  },
  "articles/guides/tracing.html": {
    "href": "articles/guides/tracing.html",
    "title": "Distributed Tracing | Orleans.StateMachineES",
    "summary": "Distributed Tracing OpenTelemetry integration for observability. Coming Soon See the Cheat Sheet for examples."
  },
  "articles/guides/versioning.html": {
    "href": "articles/guides/versioning.html",
    "title": "State Versioning | Orleans.StateMachineES",
    "summary": "State Versioning Manage state machine evolution across deployments. Coming Soon See the Cheat Sheet for examples."
  },
  "articles/guides/visualization.html": {
    "href": "articles/guides/visualization.html",
    "title": "State Visualization | Orleans.StateMachineES",
    "summary": "State Visualization Generate diagrams from your state machines. Coming Soon See the Cheat Sheet for examples."
  },
  "articles/reference/cheat-sheet.html": {
    "href": "articles/reference/cheat-sheet.html",
    "title": "Orleans.StateMachineES Developer Cheat Sheet | Orleans.StateMachineES",
    "summary": "Orleans.StateMachineES Developer Cheat Sheet Quick Start Guide 1. Basic State Machine Grain public enum OrderState { Pending, Processing, Shipped, Delivered } public enum OrderTrigger { Process, Ship, Deliver, Cancel } [StorageProvider(ProviderName = \"Default\")] public class OrderGrain : StateMachineGrain<OrderState, OrderTrigger>, IOrderGrain { protected override StateMachine<OrderState, OrderTrigger> BuildStateMachine() { var machine = new StateMachine<OrderState, OrderTrigger>(OrderState.Pending); machine.Configure(OrderState.Pending) .Permit(OrderTrigger.Process, OrderState.Processing) .Permit(OrderTrigger.Cancel, OrderState.Cancelled); machine.Configure(OrderState.Processing) .Permit(OrderTrigger.Ship, OrderState.Shipped); return machine; } public Task ProcessAsync() => FireAsync(OrderTrigger.Process); public Task ShipAsync() => FireAsync(OrderTrigger.Ship); } 2. Event Sourcing Enabled [LogConsistencyProvider(ProviderName = \"LogStorage\")] [StorageProvider(ProviderName = \"Default\")] public class OrderGrain : EventSourcedStateMachineGrain<OrderState, OrderTrigger, OrderGrainState>, IOrderGrain { protected override void ConfigureEventSourcing(EventSourcingOptions options) { options.AutoConfirmEvents = true; options.EnableSnapshots = true; options.SnapshotInterval = 100; options.EnableIdempotency = true; } } [GenerateSerializer] public class OrderGrainState : EventSourcedStateMachineState<OrderState> { [Id(0)] public string? CustomerId { get; set; } [Id(1)] public decimal Amount { get; set; } } 3. Timer-Enabled States public class OrderGrain : TimerEnabledStateMachineGrain<OrderState, OrderTrigger, OrderGrainState> { protected override void ConfigureTimeouts() { // Auto-cancel orders after 24 hours RegisterStateTimeout(OrderState.Pending, ConfigureTimeout(OrderState.Pending) .After(TimeSpan.FromHours(24)) .TransitionTo(OrderTrigger.Cancel) .UseReminder() .WithName(\"OrderExpiry\") .Build()); // Process orders within 2 hours RegisterStateTimeout(OrderState.Processing, ConfigureTimeout(OrderState.Processing) .After(TimeSpan.FromHours(2)) .TransitionTo(OrderTrigger.Ship) .UseTimer() .WithName(\"ProcessingTimeout\") .Build()); } } 4. Hierarchical States public enum DeviceState { Offline, Online, Idle, Active, Processing, Monitoring } public enum DeviceTrigger { PowerOn, PowerOff, StartProcessing, StartMonitoring, Stop } public class DeviceGrain : HierarchicalStateMachineGrain<DeviceState, DeviceTrigger, DeviceGrainState> { protected override StateMachine<DeviceState, DeviceTrigger> BuildStateMachine() { var machine = new StateMachine<DeviceState, DeviceTrigger>(DeviceState.Offline); // Configure parent states machine.Configure(DeviceState.Online) .Permit(DeviceTrigger.PowerOff, DeviceState.Offline); // Configure substates machine.Configure(DeviceState.Idle) .SubstateOf(DeviceState.Online) .Permit(DeviceTrigger.StartProcessing, DeviceState.Processing); machine.Configure(DeviceState.Processing) .SubstateOf(DeviceState.Active) .Permit(DeviceTrigger.Stop, DeviceState.Idle); return machine; } protected override void ConfigureHierarchy() { DefineSubstate(DeviceState.Idle, DeviceState.Online); DefineSubstate(DeviceState.Active, DeviceState.Online); DefineSubstate(DeviceState.Processing, DeviceState.Active); } // Query hierarchy public async Task<bool> IsOnlineAsync() => await IsInStateOrSubstateAsync(DeviceState.Online); public async Task<IReadOnlyList<DeviceState>> GetCurrentPathAsync() => await GetCurrentStatePathAsync(); } 5. Source-Generated State Machines (Roslyn Generator) YAML Specification (SmartLight.statemachine.yaml) name: SmartLight namespace: SmartHome.Devices states: [Off, On, Dimmed, ColorMode, NightMode] triggers: [TurnOn, TurnOff, Dim, SetColor, ActivateNightMode] initialState: Off transitions: - { from: Off, to: On, trigger: TurnOn } - { from: On, to: Dimmed, trigger: Dim } - { from: On, to: ColorMode, trigger: SetColor } JSON Specification (Thermostat.statemachine.json) { \"name\": \"Thermostat\", \"namespace\": \"SmartHome.Climate\", \"states\": [\"Idle\", \"Heating\", \"Cooling\", \"Auto\"], \"triggers\": [\"Heat\", \"Cool\", \"AutoMode\", \"Stop\"], \"transitions\": [ { \"from\": \"Idle\", \"to\": \"Heating\", \"trigger\": \"Heat\" }, { \"from\": \"Heating\", \"to\": \"Idle\", \"trigger\": \"Stop\" } ] } Generated Code Usage // Auto-generated interfaces and implementations ISmartLightGrain light = grainFactory.GetGrain<ISmartLightGrain>(\"living-room\"); IThermostatGrain thermostat = grainFactory.GetGrain<IThermostatGrain>(\"main\"); // Strongly-typed methods await light.FireTurnOnAsync(); await light.FireDimAsync(); bool isOn = await light.IsOnAsync(); // Generated extension methods SmartLightState.Off.IsTerminal(); SmartLightTrigger.TurnOn.GetDescription(); Project Configuration <ItemGroup> <AdditionalFiles Include=\"**\\*.statemachine.yaml\" /> <AdditionalFiles Include=\"**\\*.statemachine.json\" /> </ItemGroup> <ItemGroup> <PackageReference Include=\"Orleans.StateMachineES.Generators\" /> </ItemGroup> 6. Orthogonal Regions (Parallel State Machines) public class SmartHomeSystemGrain : OrthogonalStateMachineGrain<SmartHomeState, SmartHomeTrigger> { protected override void ConfigureOrthogonalRegions() { // Define independent regions DefineOrthogonalRegion(\"Security\", SmartHomeState.SecurityDisarmed, machine => { machine.Configure(SmartHomeState.SecurityDisarmed) .Permit(SmartHomeTrigger.ArmHome, SmartHomeState.SecurityArmedHome) .Permit(SmartHomeTrigger.ArmAway, SmartHomeState.SecurityArmedAway); machine.Configure(SmartHomeState.SecurityAlarm) .OnEntry(() => _logger.LogWarning(\"ALARM TRIGGERED!\")); }); DefineOrthogonalRegion(\"Climate\", SmartHomeState.ClimateOff, machine => { machine.Configure(SmartHomeState.ClimateOff) .Permit(SmartHomeTrigger.StartHeating, SmartHomeState.ClimateHeating) .Permit(SmartHomeTrigger.StartCooling, SmartHomeState.ClimateCooling); }); DefineOrthogonalRegion(\"Energy\", SmartHomeState.EnergyNormal, machine => { machine.Configure(SmartHomeState.EnergyNormal) .Permit(SmartHomeTrigger.EnterPeakDemand, SmartHomeState.EnergyPeakDemand) .Permit(SmartHomeTrigger.EnableSaving, SmartHomeState.EnergySaving); }); // Map triggers to regions MapTriggerToRegions(SmartHomeTrigger.VacationMode, \"Security\", \"Climate\", \"Energy\"); } // Cross-region synchronization protected override async Task OnRegionStateChangedAsync( string regionName, SmartHomeState prev, SmartHomeState next, SmartHomeTrigger trigger) { if (regionName == \"Presence\" && next == SmartHomeState.PresenceAway) { // Auto-adjust when leaving home await FireInRegionAsync(\"Security\", SmartHomeTrigger.ArmAway); await FireInRegionAsync(\"Climate\", SmartHomeTrigger.SetEco); await FireInRegionAsync(\"Energy\", SmartHomeTrigger.EnableSaving); } } // Usage public async Task ActivateVacationModeAsync() { await FireInRegionAsync(\"Presence\", SmartHomeTrigger.StartVacation); await FireInRegionAsync(\"Security\", SmartHomeTrigger.ArmAway); await FireInRegionAsync(\"Climate\", SmartHomeTrigger.SetEco); await FireInRegionAsync(\"Energy\", SmartHomeTrigger.EnableSaving); } } // Client usage var smartHome = grainFactory.GetGrain<ISmartHomeSystemGrain>(\"my-home\"); await smartHome.FireInRegionAsync(\"Security\", SmartHomeTrigger.ArmHome); await smartHome.FireInRegionAsync(\"Climate\", SmartHomeTrigger.StartHeating); var status = await smartHome.GetStateSummary(); Console.WriteLine($\"Security: {status.RegionStates[\"Security\"]}\"); Console.WriteLine($\"Climate: {status.RegionStates[\"Climate\"]}\"); Core Interfaces & Methods IStateMachineGrain<TState, TTrigger> // State queries Task<TState> GetStateAsync(); Task<bool> IsInStateAsync(TState state); Task<IEnumerable<TTrigger>> GetPermittedTriggersAsync(); // Trigger execution Task FireAsync(TTrigger trigger); Task FireAsync<TArg0>(TTrigger trigger, TArg0 arg0); Task FireAsync<TArg0, TArg1>(TTrigger trigger, TArg0 arg0, TArg1 arg1); // Guard validation Task<bool> CanFireAsync(TTrigger trigger); Task<(bool, ICollection<string>)> CanFireWithUnmetGuardsAsync(TTrigger trigger); // Lifecycle Task ActivateAsync(); Task DeactivateAsync(); Timer Configuration protected TimeoutConfiguration<TState, TTrigger> ConfigureTimeout(TState state) { return new TimeoutConfiguration<TState, TTrigger>(state) .After(TimeSpan.FromMinutes(5)) // Duration .TransitionTo(OrderTrigger.Timeout) // Target trigger .UseTimer() // or .UseReminder() .WithName(\"MyTimeout\") // Optional name .WithMetadata(new { reason = \"expired\" }) // Optional metadata .Build(); } Event Sourcing Options \uD83D\uDE80 PERFORMANCE BREAKTHROUGH: Event sourcing is 30.4% FASTER than regular state machines! Event-sourced: 5,923 transitions/sec (0.17ms latency) Regular: 4,123 transitions/sec (0.24ms latency) protected override void ConfigureEventSourcing(EventSourcingOptions options) { options.AutoConfirmEvents = true; // Essential for optimal performance // Performance optimizations options.EnableSnapshots = true; // Enable periodic snapshots options.SnapshotInterval = 100; // Events between snapshots options.EnableIdempotency = true; // Deduplicate triggers options.MaxDedupeKeysInMemory = 1000; // LRU cache size // Optional stream publishing options.PublishToStream = true; // Publish to Orleans Streams options.StreamProvider = \"SMS\"; // Stream provider name options.StreamNamespace = \"Events\"; // Stream namespace } ⚠️ CRITICAL: AutoConfirmEvents = true is essential for: Maximum performance Proper state recovery after grain deactivation Reliable event persistence Hierarchical State Queries // Parent-child relationships Task<TState?> GetParentStateAsync(TState state); Task<IReadOnlyList<TState>> GetSubstatesAsync(TState parentState); Task<IReadOnlyList<TState>> GetAncestorStatesAsync(TState state); Task<IReadOnlyList<TState>> GetDescendantStatesAsync(TState parentState); // Hierarchy navigation Task<bool> IsInStateOrSubstateAsync(TState state); Task<IReadOnlyList<TState>> GetCurrentStatePathAsync(); Task<TState?> GetActiveSubstateAsync(TState parentState); Task<HierarchicalStateInfo<TState>> GetHierarchicalInfoAsync(); Common Patterns Guards & Conditional Transitions machine.Configure(OrderState.Processing) .PermitIf(OrderTrigger.Ship, OrderState.Shipped, () => HasInventory() && IsPaymentConfirmed()) .OnEntry(() => Logger.LogInformation(\"Started processing order\")); Parameterized Triggers public async Task ProcessWithPriorityAsync(int priority) { await FireAsync(OrderTrigger.ProcessWithPriority, priority); } // In BuildStateMachine: var priorityTrigger = machine.SetTriggerParameters<int>(OrderTrigger.ProcessWithPriority); machine.Configure(OrderState.Pending) .Permit(priorityTrigger, OrderState.Processing); Custom State Classes [GenerateSerializer] public class OrderGrainState : EventSourcedStateMachineState<OrderState> { [Id(0)] public string CustomerId { get; set; } = \"\"; [Id(1)] public List<OrderItem> Items { get; set; } = new(); [Id(2)] public decimal Total { get; set; } [Id(3)] public DateTime OrderDate { get; set; } } Stream Integration // Configure in silo siloBuilder.AddStreams(StreamConfigurator.StreamProvider) .AddMemoryStreams(\"SMS\"); // In grain protected override void ConfigureEventSourcing(EventSourcingOptions options) { options.PublishToStream = true; options.StreamProvider = \"SMS\"; options.StreamNamespace = \"OrderEvents\"; } Testing Patterns Basic Testing [Fact] public async Task Should_Process_Order_Successfully() { var grain = _cluster.Client.GetGrain<IOrderGrain>(\"order-123\"); await grain.ProcessAsync(); var state = await grain.GetStateAsync(); state.Should().Be(OrderState.Processing); } Timer Testing [Fact] public async Task Should_Timeout_After_Configured_Duration() { var grain = _cluster.Client.GetGrain<IOrderGrain>(\"order-timeout\"); await grain.ProcessAsync(); await Task.Delay(TimeSpan.FromSeconds(3)); // Wait for timeout var state = await grain.GetStateAsync(); state.Should().Be(OrderState.Cancelled); } Hierarchical Testing [Fact] public async Task Should_Navigate_Hierarchy_Correctly() { var grain = _cluster.Client.GetGrain<IDeviceGrain>(\"device-123\"); await grain.PowerOnAsync(); await grain.StartProcessingAsync(); (await grain.IsInStateOrSubstateAsync(DeviceState.Online)).Should().BeTrue(); (await grain.IsInStateAsync(DeviceState.Processing)).Should().BeTrue(); var path = await grain.GetCurrentStatePathAsync(); path.Should().ContainInOrder(DeviceState.Online, DeviceState.Active, DeviceState.Processing); } 5. Distributed Sagas using Orleans.StateMachineES.Sagas; public class InvoiceProcessingSaga : SagaOrchestratorGrain<InvoiceData>, IInvoiceProcessingSagaGrain { protected override void ConfigureSagaSteps() { AddStep(new PostInvoiceStep()) .WithTimeout(TimeSpan.FromSeconds(30)) .WithRetry(3) .WithMetadata(\"Description\", \"Posts invoice to accounting system\"); AddStep(new CreateJournalEntryStep()) .WithTimeout(TimeSpan.FromSeconds(45)) .WithRetry(2) .WithMetadata(\"Description\", \"Creates journal entries\"); AddStep(new RunControlCheckStep()) .WithTimeout(TimeSpan.FromSeconds(60)) .WithRetry(1) .WithMetadata(\"Description\", \"Runs compliance control checks\"); } protected override string GenerateBusinessTransactionId(InvoiceData sagaData) { return $\"INV-TXN-{sagaData.InvoiceId}-{DateTime.UtcNow:yyyyMMddHHmmss}\"; } } // Example saga step implementation public class PostInvoiceStep : ISagaStep<InvoiceData> { public string StepName => \"PostInvoice\"; public TimeSpan Timeout => TimeSpan.FromSeconds(30); public bool CanRetry => true; public int MaxRetryAttempts => 3; public async Task<SagaStepResult> ExecuteAsync(InvoiceData sagaData, SagaContext context) { try { var invoiceGrain = GrainFactory.GetGrain<IInvoiceGrain>(sagaData.InvoiceId); var result = await invoiceGrain.PostAsync(sagaData, context.CorrelationId); return SagaStepResult.Success(result); } catch (BusinessRuleException ex) { return SagaStepResult.BusinessFailure(ex.Message); } catch (Exception ex) { return SagaStepResult.TechnicalFailure(ex.Message, ex); } } public async Task<CompensationResult> CompensateAsync( InvoiceData sagaData, SagaStepResult? stepResult, SagaContext context) { try { var invoiceGrain = GrainFactory.GetGrain<IInvoiceGrain>(sagaData.InvoiceId); await invoiceGrain.CancelAsync(context.CorrelationId); return CompensationResult.Success(); } catch (Exception ex) { return CompensationResult.Failure($\"Failed to compensate invoice: {ex.Message}\", ex); } } } Usage Examples // Execute saga var sagaGrain = grainFactory.GetGrain<IInvoiceProcessingSagaGrain>(\"saga-123\"); var correlationId = Guid.NewGuid().ToString(\"N\"); var invoiceData = new InvoiceData { InvoiceId = \"INV-001\", CustomerId = \"CUST-123\", Amount = 1500.00m }; var result = await sagaGrain.ExecuteAsync(invoiceData, correlationId); if (result.IsSuccess) { Console.WriteLine(\"Saga completed successfully\"); } else if (result.IsCompensated) { Console.WriteLine(\"Saga failed but was compensated successfully\"); } // Check saga status var status = await sagaGrain.GetStatusAsync(); Console.WriteLine($\"Saga status: {status.Status}\"); Console.WriteLine($\"Current step: {status.CurrentStepName}\"); Console.WriteLine($\"Progress: {status.CurrentStepIndex + 1}/{status.TotalSteps}\"); // Get detailed execution history var history = await sagaGrain.GetHistoryAsync(); foreach (var step in history.StepExecutions) { Console.WriteLine($\"Step {step.StepName}: {step.IsSuccess} ({step.Duration.TotalMilliseconds}ms)\"); } Saga Features Orchestration Pattern: Central coordinator manages business process flow Automatic Compensation: Failed steps trigger rollback of completed steps in reverse order Retry Logic: Configurable retry attempts with exponential backoff for technical failures Correlation Tracking: Full correlation ID propagation across all distributed operations Event Sourcing Integration: Complete audit trail of saga execution and compensation Timeout Handling: Per-step timeouts with graceful failure handling Hierarchical State Management: Extends hierarchical state machine capabilities Business vs Technical Errors: Different handling strategies for different error types 6. State Machine Versioning using Orleans.StateMachineES.Versioning; public class VersionedOrderGrain : VersionedStateMachineGrain<OrderState, OrderTrigger, VersionedOrderState>, IVersionedOrderGrain { protected override async Task RegisterBuiltInVersionsAsync() { if (DefinitionRegistry != null) { // Register version 1.0.0 await DefinitionRegistry.RegisterDefinitionAsync<OrderState, OrderTrigger>( GetType().Name, new StateMachineVersion(1, 0, 0), () => BuildOrderWorkflowV1(), new StateMachineDefinitionMetadata { Description = \"Initial order workflow\", Features = { \"Basic order processing\" } }); // Register version 1.1.0 (backward compatible) await DefinitionRegistry.RegisterDefinitionAsync<OrderState, OrderTrigger>( GetType().Name, new StateMachineVersion(1, 1, 0), () => BuildOrderWorkflowV11(), new StateMachineDefinitionMetadata { Description = \"Enhanced order workflow\", Features = { \"Enhanced validation\", \"Better error handling\" } }); // Register version 2.0.0 (breaking changes) await DefinitionRegistry.RegisterDefinitionAsync<OrderState, OrderTrigger>( GetType().Name, new StateMachineVersion(2, 0, 0), () => BuildOrderWorkflowV2(), new StateMachineDefinitionMetadata { Description = \"Major refactor\", Features = { \"New approval workflow\", \"Multi-step processing\" }, BreakingChanges = { \"Added approval states\", \"Changed validation rules\" } }); } } protected override Task<StateMachine<OrderState, OrderTrigger>?> BuildVersionedStateMachineAsync( StateMachineVersion version) { return Task.FromResult(version switch { { Major: 1, Minor: 0, Patch: 0 } => BuildOrderWorkflowV1(), { Major: 1, Minor: 1, Patch: 0 } => BuildOrderWorkflowV11(), { Major: 2, Minor: 0, Patch: 0 } => BuildOrderWorkflowV2(), _ => (StateMachine<OrderState, OrderTrigger>?)null }); } } Usage Examples // Check current version var grain = grainFactory.GetGrain<IVersionedOrderGrain>(\"order-123\"); var version = await grain.GetVersionAsync(); Console.WriteLine($\"Current version: {version}\"); // Get version compatibility info var compatibility = await grain.GetVersionCompatibilityAsync(); Console.WriteLine($\"Available versions: {string.Join(\", \", compatibility.AvailableVersions)}\"); // Upgrade to new version var upgradeResult = await grain.UpgradeToVersionAsync( new StateMachineVersion(1, 1, 0), MigrationStrategy.Automatic); if (upgradeResult.IsSuccess) { Console.WriteLine($\"Upgraded to {upgradeResult.NewVersion} in {upgradeResult.UpgradeDuration.TotalMilliseconds}ms\"); } // Shadow evaluation - test without committing var shadowResult = await grain.RunShadowEvaluationAsync( new StateMachineVersion(2, 0, 0), OrderTrigger.Submit); if (shadowResult.WouldSucceed) { Console.WriteLine($\"Shadow: {shadowResult.CurrentState} -> {shadowResult.PredictedState}\"); // Safe to upgrade } // Blue-green deployment var blueGreenResult = await grain.UpgradeToVersionAsync( new StateMachineVersion(2, 0, 0), MigrationStrategy.BlueGreen); // Custom migration with hooks var customResult = await grain.UpgradeToVersionAsync( new StateMachineVersion(2, 0, 0), MigrationStrategy.Custom); Migration Hooks public class CustomMigrationHook : IMigrationHook { public string HookName => \"CustomDataMigration\"; public int Priority => 50; public async Task<bool> BeforeMigrationAsync(MigrationContext context) { // Pre-migration validation and data transformation if (context.ToVersion.Major > context.FromVersion.Major) { // Handle breaking changes var data = context.GetStateValue<OrderData>(\"OrderData\"); if (data != null) { var transformed = TransformForNewVersion(data); context.SetStateValue(\"OrderData\", transformed); } } return true; } public async Task AfterMigrationAsync(MigrationContext context) { // Post-migration verification Console.WriteLine($\"Migration completed for {context.GrainId}\"); } public async Task OnMigrationRollbackAsync(MigrationContext context, Exception error) { // Rollback custom changes Console.WriteLine($\"Rolling back migration: {error.Message}\"); } } Version Compatibility Checking var checker = serviceProvider.GetRequiredService<IVersionCompatibilityChecker>(); // Check upgrade compatibility var result = await checker.CheckCompatibilityAsync( \"OrderGrain\", new StateMachineVersion(1, 0, 0), new StateMachineVersion(2, 0, 0)); if (!result.IsCompatible) { foreach (var change in result.BreakingChanges) { Console.WriteLine($\"Breaking change: {change.Description}\"); Console.WriteLine($\"Impact: {change.Impact}, Mitigation: {change.Mitigation}\"); } } // Get upgrade recommendations var recommendations = await checker.GetUpgradeRecommendationsAsync( \"OrderGrain\", new StateMachineVersion(1, 0, 0)); foreach (var rec in recommendations) { Console.WriteLine($\"Upgrade to {rec.ToVersion}: {rec.RecommendationType}\"); Console.WriteLine($\"Risk: {rec.RiskLevel}, Effort: {rec.EstimatedEffort}\"); } Versioning Features Semantic Versioning: Full major.minor.patch version support with pre-release and build metadata Backward Compatibility: Automatic compatibility checking for minor version upgrades Breaking Change Detection: Identifies and documents breaking changes in major versions Migration Strategies: Automatic, custom, blue-green, and dry-run migration options Shadow Evaluation: Test new versions without affecting live state Migration Hooks: Extensible system for custom migration logic with priorities Rollback Support: Automatic state backup and rollback on migration failure Deployment Validation: Check compatibility with existing deployed versions Audit Trail: Complete history of version upgrades and migrations Best Practices 1. State Machine Design Keep states focused and meaningful Use hierarchical states for related behaviors Design for testability with clear state transitions Enable nullable reference types (<Nullable>enable</Nullable>) for better null safety 2. Performance Use timers for short durations (< 5 minutes) Use reminders for long durations (> 5 minutes) Enable snapshots for high-frequency state machines Configure appropriate dedupe key limits Optimize async methods by removing unnecessary async keywords where no await is needed 3. Error Handling try { await FireAsync(OrderTrigger.Process); } catch (InvalidStateTransitionException ex) { Logger.LogWarning(\"Invalid transition: {Message}\", ex.Message); // Handle invalid transition gracefully } 4. Orleans Configuration // In Program.cs siloBuilder .AddMemoryGrainStorage(\"Default\") .AddLogStorageBasedLogConsistencyProvider(\"LogStorage\") .AddMemoryGrainStorage(\"PubSubStore\") .AddStreams(\"SMS\") .AddMemoryStreams(\"SMS\"); 5. Build Configuration <!-- Recommended project settings for Orleans.StateMachineES --> <PropertyGroup> <TargetFramework>net9.0</TargetFramework> <Nullable>enable</Nullable> <ImplicitUsings>enable</ImplicitUsings> <TreatWarningsAsErrors>false</TreatWarningsAsErrors> </PropertyGroup> <!-- Package references with verified compatibility --> <ItemGroup> <PackageReference Include=\"Orleans.StateMachineES\" Version=\"1.0.1\" /> <PackageReference Include=\"Microsoft.Orleans.Sdk\" Version=\"9.1.2\" /> <!-- For testing --> <PackageReference Include=\"xunit\" Version=\"2.8.0\" /> <PackageReference Include=\"FluentAssertions\" Version=\"7.0.0\" /> </ItemGroup> 6. Monitoring & Observability protected override async Task RecordTransitionEvent(/*...*/) { // Add custom telemetry using var activity = ActivitySource.StartActivity(\"StateMachine.Transition\"); activity?.SetTag(\"grain.id\", GetPrimaryKeyString()); activity?.SetTag(\"from.state\", fromState.ToString()); activity?.SetTag(\"to.state\", toState.ToString()); await base.RecordTransitionEvent(/*...*/); } Troubleshooting Common Issues InvalidStateTransitionException: Check permitted triggers with GetPermittedTriggersAsync() Timer not firing: Verify reminder/timer registration and Orleans configuration Events not persisting: Check log consistency provider configuration Hierarchy not working: Ensure both SubstateOf() and DefineSubstate() are called Debug Commands // Check current state and permitted triggers var state = await grain.GetStateAsync(); var triggers = await grain.GetPermittedTriggersAsync(); var info = await grain.GetInfoAsync(); // For hierarchical grains var hierarchy = await grain.GetHierarchicalInfoAsync(); var path = await grain.GetCurrentStatePathAsync(); Complete Example Applications The examples/ directory contains four applications: ECommerceWorkflow - Order processing with event sourcing, timers, and monitoring DocumentApproval - Hierarchical states with saga orchestration MonitoringDashboard - Health checks, metrics, and visualization SmartHome - Source generator and orthogonal regions demonstration SmartHome Example Highlights The SmartHome example demonstrates the newest features: State machines generated from YAML/JSON specifications Orthogonal regions with 4 independent subsystems (Security, Climate, Energy, Presence) Cross-region synchronization and reactions Integration between generated device grains and orthogonal system grain See examples/README.md for complete documentation and usage instructions. This cheat sheet covers all major features of Orleans.StateMachineES. For detailed examples, see the test projects and documentation."
  },
  "articles/reference/configuration.html": {
    "href": "articles/reference/configuration.html",
    "title": "configuration | Orleans.StateMachineES",
    "summary": "configuration Documentation coming soon. See the README for general information."
  },
  "articles/reference/contributing.html": {
    "href": "articles/reference/contributing.html",
    "title": "contributing | Orleans.StateMachineES",
    "summary": "contributing Documentation coming soon. See the README for general information."
  },
  "articles/reference/faq.html": {
    "href": "articles/reference/faq.html",
    "title": "faq | Orleans.StateMachineES",
    "summary": "faq Documentation coming soon. See the README for general information."
  },
  "articles/reference/index.html": {
    "href": "articles/reference/index.html",
    "title": "Reference | Orleans.StateMachineES",
    "summary": "Reference Quick reference materials for Orleans.StateMachineES. Available References Cheat Sheet - Comprehensive developer quick reference Migration Guide - Upgrading from previous versions Troubleshooting - Common issues and solutions Configuration - Configuration reference FAQ - Frequently asked questions Contributing - How to contribute to the project Release Notes - Version history and changes"
  },
  "articles/reference/migration-guide.html": {
    "href": "articles/reference/migration-guide.html",
    "title": "Migration Guide: From ManagedCode.Orleans.StateMachine to Orleans.StateMachineES | Orleans.StateMachineES",
    "summary": "Migration Guide: From ManagedCode.Orleans.StateMachine to Orleans.StateMachineES Overview This guide helps you migrate from the original ManagedCode.Orleans.StateMachine library to the enhanced Orleans.StateMachineES library with event sourcing capabilities. Key Differences 1. Namespace Changes Old: ManagedCode.Orleans.StateMachine New: Orleans.StateMachineES 2. New Features Event Sourcing: Automatic persistence of state transitions as events JournaledGrain Integration: Built on Orleans' event sourcing foundation Idempotency: Built-in deduplication for repeated triggers Stream Publishing: Optional publishing of events to Orleans Streams Correlation Tracking: Built-in correlation ID support for distributed tracing Migration Steps Step 1: Update NuGet Package Remove the old package: dotnet remove package ManagedCode.Orleans.StateMachine Add the new package: dotnet add package Orleans.StateMachineES Step 2: Update Namespace Imports Update all your using statements: // Old using ManagedCode.Orleans.StateMachine; using ManagedCode.Orleans.StateMachine.Interfaces; using ManagedCode.Orleans.StateMachine.Models; using ManagedCode.Orleans.StateMachine.Extensions; // New using Orleans.StateMachineES; using Orleans.StateMachineES.Interfaces; using Orleans.StateMachineES.Models; using Orleans.StateMachineES.Extensions; Step 3: Choose Your Base Class You have two options: Option A: Keep Using Non-Event-Sourced (Minimal Changes) Continue using StateMachineGrain for backward compatibility: public class MyGrain : StateMachineGrain<MyState, MyTrigger>, IMyGrain { // No changes needed to your existing code } Option B: Upgrade to Event Sourcing (Recommended) Migrate to EventSourcedStateMachineGrain for event sourcing benefits: // Define your grain state public class MyGrainState : EventSourcedStateMachineState<MyState> { // Add any additional state properties if needed } // Update your grain class public class MyGrain : EventSourcedStateMachineGrain<MyState, MyTrigger, MyGrainState>, IMyGrain { protected override StateMachine<MyState, MyTrigger> BuildStateMachine() { // Your existing state machine configuration } // Optional: Configure event sourcing protected override void ConfigureEventSourcing(EventSourcingOptions options) { options.AutoConfirmEvents = true; options.PublishToStream = true; options.StreamProvider = \"SMS\"; options.EnableIdempotency = true; } // Optional: Customize version for migration tracking protected override string GetStateMachineVersion() { return \"2.0.0\"; // Your version } } Step 4: Update Silo Configuration Add event sourcing storage provider to your silo configuration: siloBuilder .AddLogStorageBasedLogConsistencyProvider() .AddStateStorageBasedLogConsistencyProvider() .AddMemoryGrainStorage(\"EventStore\") // Or use Azure/ADO.NET storage .AddMemoryStreams(\"SMS\"); // Optional: for stream publishing Step 5: Handle Breaking Changes Interface Changes The core IStateMachineGrain<TState, TTrigger> interface remains the same, so no changes are needed to your grain interfaces. Extension Methods The Orleans context extension methods remain compatible: // Still works the same machine.Configure(State.Active) .OnEntryOrleansContextAsync(async () => { /* ... */ }) .OnExitOrleansContextAsync(async () => { /* ... */ }); Event Sourcing Benefits When you migrate to EventSourcedStateMachineGrain, you automatically get: 1. Event Persistence Every state transition is automatically persisted as an event: // This automatically creates a StateTransitionEvent await grain.FireAsync(MyTrigger.Start); 2. Event Replay State is automatically restored from events on grain activation. 3. Idempotency Duplicate triggers are automatically ignored: // Second call with same parameters is ignored (idempotent) await grain.FireAsync(MyTrigger.Process, \"job-123\"); await grain.FireAsync(MyTrigger.Process, \"job-123\"); // No-op 4. Correlation Tracking Track related operations across grains: grain.SetCorrelationId(\"request-123\"); await grain.FireAsync(MyTrigger.Process); // Event includes correlation ID 5. Stream Publishing Events can be automatically published to Orleans Streams: protected override void ConfigureEventSourcing(EventSourcingOptions options) { options.PublishToStream = true; options.StreamProvider = \"SMS\"; } Testing Your Migration 1. Unit Tests Your existing unit tests should continue to work. For event-sourced grains, add tests for: Event persistence Idempotency Event replay 2. Integration Tests Test the full event sourcing flow: [Fact] public async Task EventSourcedGrain_PersistsTransitions() { var grain = cluster.GrainFactory.GetGrain<IMyGrain>(\"test\"); // Fire trigger await grain.FireAsync(MyTrigger.Start); // Deactivate and reactivate grain // ... grain deactivation logic ... // State should be restored from events var state = await grain.GetStateAsync(); Assert.Equal(MyState.Started, state); } Rollback Plan If you need to rollback to the original library: Keep the namespace as Orleans.StateMachineES but use StateMachineGrain base class Or create type aliases: global using StateMachineGrain = Orleans.StateMachineES.StateMachineGrain; Common Issues and Solutions Issue 1: State Not Persisting Solution: Ensure you've configured a log consistency provider and storage provider. Issue 2: Duplicate Events Solution: Enable idempotency in options and ensure dedupe keys are unique. Issue 3: Performance Impact Solution: Tune snapshot intervals: options.EnableSnapshots = true; options.SnapshotInterval = 50; // Snapshot every 50 events Getting Help Documentation: See README.md Examples: Check the test project for usage examples Issues: Report issues on GitHub Acknowledgments This library is based on the excellent work of the ManagedCode team. We've extended it with event sourcing capabilities while maintaining backward compatibility where possible."
  },
  "articles/reference/release-notes.html": {
    "href": "articles/reference/release-notes.html",
    "title": "release-notes | Orleans.StateMachineES",
    "summary": "release-notes Documentation coming soon. See the README for general information."
  },
  "articles/reference/troubleshooting.html": {
    "href": "articles/reference/troubleshooting.html",
    "title": "troubleshooting | Orleans.StateMachineES",
    "summary": "troubleshooting Documentation coming soon. See the README for general information."
  },
  "index.html": {
    "href": "index.html",
    "title": "Orleans.StateMachineES | Orleans.StateMachineES",
    "summary": "Orleans.StateMachineES Production-ready state machines for Microsoft Orleans Orleans.StateMachineES brings the power of state machines to your Orleans applications, wrapping the battle-tested Stateless library with Orleans-native async APIs, event sourcing, and advanced distributed patterns. Why Orleans.StateMachineES? Build reliable, maintainable distributed systems with: Compile-time Safety: 10 Roslyn analyzers catch state machine anti-patterns before they reach production Event Sourcing Built-in: Complete state history with replay capabilities - and it's 30% faster than regular state machines Production Resilience: Circuit breakers, retries, validation components, and distributed tracing out of the box Advanced Patterns: Hierarchical states, distributed sagas, orthogonal regions, and versioning High Performance: TriggerParameterCache provides ~100x speedup for parameterized triggers, optimized object pooling Quick Start Installation dotnet add package Orleans.StateMachineES dotnet add package Orleans.StateMachineES.Generators Your First State Machine using Orleans.StateMachineES; public enum OrderState { Pending, Confirmed, Shipped, Delivered } public enum OrderTrigger { Confirm, Ship, Deliver } public interface IOrderGrain : IStateMachineGrain<OrderState, OrderTrigger> { } public class OrderGrain : StateMachineGrain<OrderState, OrderTrigger>, IOrderGrain { protected override void BuildStateMachine() { StateMachine.Configure(OrderState.Pending) .Permit(OrderTrigger.Confirm, OrderState.Confirmed) .OnEntry(() => GrainFactory.GetGrain<INotificationGrain>(0) .SendEmailAsync(\"Order received!\")); StateMachine.Configure(OrderState.Confirmed) .Permit(OrderTrigger.Ship, OrderState.Shipped); StateMachine.Configure(OrderState.Shipped) .Permit(OrderTrigger.Deliver, OrderState.Delivered); } } Usage var order = grainFactory.GetGrain<IOrderGrain>(orderId); // Fire transitions await order.FireAsync(OrderTrigger.Confirm); await order.FireAsync(OrderTrigger.Ship); // Query state var currentState = await order.GetStateAsync(); // OrderState.Shipped var canDeliver = await order.CanFireAsync(OrderTrigger.Deliver); // true var permitted = await order.GetPermittedTriggersAsync(); // [OrderTrigger.Deliver] Learn more in the Getting Started guide → Key Features Core State Machines The foundation of distributed state management with Orleans. StateMachineGrain Base Class: Orleans-native async state machine grain Parameterized Triggers: Pass up to 3 typed arguments with transitions Guard Conditions: Validate transitions with business logic State Inspection: Query current state, permitted triggers, and guard status Explore Core Concepts → Event Sourcing Complete state history and replay capabilities - 30.4% faster than regular state machines. public class OrderGrain : EventSourcedStateMachineGrain<OrderState, OrderTrigger> { // Automatic event persistence and replay // Use AutoConfirmEvents = true for maximum performance } Automatic Event Persistence: All transitions saved as events State Replay: Rebuild grain state from event history Idempotency: Safe re-execution of transitions Stream Publishing: Orleans streams integration Learn about Event Sourcing → Advanced Patterns Hierarchical States: Parent-child state relationships with substates StateMachine.Configure(OrderState.InTransit) .SubstateOf(OrderState.Active) .Permit(OrderTrigger.Delay, OrderState.Delayed); Distributed Sagas: Multi-grain workflows with compensation var saga = new OrderSaga(); await saga.ExecuteAsync(context); // Automatic compensation on failure Orthogonal Regions: Parallel independent state machines var regions = new OrthogonalRegions<SmartHomeState, SmartHomeTrigger>(); regions.AddRegion(\"Lighting\", lightingStateMachine); regions.AddRegion(\"Climate\", climateStateMachine); Explore Advanced Patterns → Production Features Circuit Breaker: Prevent cascading failures var circuitBreaker = new CircuitBreakerComponent<State, Trigger>(new() { FailureThreshold = 5, SuccessThreshold = 2, OpenDuration = TimeSpan.FromSeconds(30) }); Distributed Tracing: OpenTelemetry integration for observability Health Checks: ASP.NET Core health monitoring Versioning: Manage state machine evolution across deployments Read Production Guide → Compile-time Safety 10 Roslyn analyzers catch issues before deployment: Analyzer Description OSMES001 Prevents async lambdas in callbacks OSMES002 Blocks FireAsync in state callbacks OSMES003 Requires BuildStateMachine implementation OSMES004 Detects unreachable states OSMES009 Ensures initial state is set ...and 5 more See all analyzers → Visualization Generate diagrams from your state machines: var visualization = new StateMachineVisualization<State, Trigger>(stateMachine); var mermaid = visualization.GenerateMermaidDiagram(); var dot = visualization.GenerateDotGraph(); var plantuml = visualization.GeneratePlantUmlDiagram(); var html = visualization.GenerateHtmlDiagram(); Learn about Visualization → Performance Optimized for production workloads: Event Sourcing: 5,923 transitions/sec (30% faster than regular grains) TriggerParameterCache: ~100x performance improvement for parameterized triggers ValueTask: Zero-allocation paths for synchronous operations FrozenCollections: 40%+ faster lookups in .NET 8+ Object Pooling: Thread-safe, high-performance resource management Read Performance Guide → Complete Examples Explore production-ready applications: E-Commerce Workflow: Event sourcing, timers, sagas Document Approval: Hierarchical states, multi-level approval Monitoring Dashboard: Health checks, metrics, observability Smart Home Automation: Orthogonal regions, source generator Browse all examples → Documentation For Developers Getting Started - Installation and first state machine Core Concepts - Fundamental patterns Async Patterns - Critical async operation guidelines Cheat Sheet - Quick reference guide For Architects Architecture Overview - Design decisions and patterns Performance Tuning - Optimization strategies Production Deployment - Production best practices For Contributors Contributing Guide - How to contribute Analyzer Development - Writing analyzers Testing Strategy - Testing approach API Reference Browse the complete API documentation for all packages: Orleans.StateMachineES - Main library Orleans.StateMachineES.Abstractions - Core interfaces Orleans.StateMachineES.Generators - Analyzers and generators Explore API Reference → Version Information Current Version: 1.0.4 (Released November 2025) Latest Improvements: Event sourcing performance: 30.4% faster with AutoConfirmEvents Enhanced production resilience components Comprehensive analyzer suite (10 analyzers) Performance optimizations across the board View Changelog | Migration Guide Community & Support GitHub: Orleans.StateMachineES Repository Issues: Report a bug Discussions: Ask questions NuGet: Package Downloads License Orleans.StateMachineES is licensed under the MIT License. Ready to get started? Install Orleans.StateMachineES →"
  }
}