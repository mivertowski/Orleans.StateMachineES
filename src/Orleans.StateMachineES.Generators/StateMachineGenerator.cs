using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Orleans.StateMachineES.Generators;

/// <summary>
/// Roslyn source generator that creates typed state machines from YAML/JSON specifications.
/// </summary>
[Generator]
public class StateMachineGenerator : ISourceGenerator
{
    /// <summary>
    /// Initializes the generator. Called before Execute during each generation pass.
    /// </summary>
    /// <param name="context">The initialization context provided by the compiler.</param>
    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization required for this generator
    }

    /// <summary>
    /// Executes the source generator to create typed state machines from YAML/JSON specifications.
    /// </summary>
    /// <param name="context">The execution context provided by the compiler.</param>
    public void Execute(GeneratorExecutionContext context)
    {
        // Find all additional files with .statemachine.yaml or .statemachine.json extension
        var stateMachineFiles = context.AdditionalFiles
            .Where(file => file.Path.EndsWith(".statemachine.yaml", StringComparison.OrdinalIgnoreCase) ||
                          file.Path.EndsWith(".statemachine.json", StringComparison.OrdinalIgnoreCase));

        foreach (var file in stateMachineFiles)
        {
            try
            {
                var content = file.GetText(context.CancellationToken)?.ToString();
                if (string.IsNullOrEmpty(content))
                    continue;

                StateMachineDefinition? definition = null;

                if (file.Path.EndsWith(".yaml", StringComparison.OrdinalIgnoreCase))
                {
                    var deserializer = new DeserializerBuilder()
                        .WithNamingConvention(CamelCaseNamingConvention.Instance)
                        .Build();
                    definition = deserializer.Deserialize<StateMachineDefinition>(content!);
                }
                else if (file.Path.EndsWith(".json", StringComparison.OrdinalIgnoreCase))
                {
                    definition = JsonSerializer.Deserialize<StateMachineDefinition>(content!, new JsonSerializerOptions
                    {
                        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
                    });
                }

                if (definition != null)
                {
                    var source = GenerateStateMachineCode(definition);
                    var fileName = $"{definition.Name}StateMachine.g.cs";
                    context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
                }
            }
            catch (Exception ex)
            {
                var diagnostic = Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "OSMSG001",
                        "State Machine Generation Error",
                        $"Error generating state machine from {Path.GetFileName(file.Path)}: {ex.Message}",
                        "Orleans.StateMachineES.Generators",
                        DiagnosticSeverity.Error,
                        true),
                    Location.None);
                
                context.ReportDiagnostic(diagnostic);
            }
        }
    }

    private string GenerateStateMachineCode(StateMachineDefinition definition)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Orleans;");
        sb.AppendLine("using Orleans.StateMachineES;");
        sb.AppendLine("using Stateless;");
        sb.AppendLine();

        // Namespace
        sb.AppendLine($"namespace {definition.Namespace ?? "Generated.StateMachines"}");
        sb.AppendLine("{");

        // Generate State enum
        GenerateEnum(sb, $"{definition.Name}State", definition.States, definition.Description);

        // Generate Trigger enum
        GenerateEnum(sb, $"{definition.Name}Trigger", definition.Triggers, null);

        // Generate Grain Interface
        GenerateGrainInterface(sb, definition);

        // Generate Grain Implementation
        GenerateGrainImplementation(sb, definition);

        // Generate Helper Extensions
        GenerateHelperExtensions(sb, definition);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private void GenerateEnum(StringBuilder sb, string enumName, List<string> values, string? description)
    {
        if (description != null)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// {description}");
            sb.AppendLine($"    /// </summary>");
        }
        
        sb.AppendLine($"    public enum {enumName}");
        sb.AppendLine("    {");
        
        foreach (var value in values)
        {
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// {ToSentenceCase(value)} state/trigger");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        {value},");
        }
        
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private void GenerateGrainInterface(StringBuilder sb, StateMachineDefinition definition)
    {
        var stateName = $"{definition.Name}State";
        var triggerName = $"{definition.Name}Trigger";
        
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Grain interface for {definition.Name} state machine");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public interface I{definition.Name}Grain : IStateMachineGrain<{stateName}, {triggerName}>, IGrainWithStringKey");
        sb.AppendLine("    {");
        
        // Generate typed trigger methods
        foreach (var trigger in definition.Triggers)
        {
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Fires the {trigger} trigger");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        Task Fire{trigger}Async();");
            sb.AppendLine();
        }
        
        // Generate state check methods
        foreach (var state in definition.States)
        {
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Checks if the state machine is in {state} state");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        Task<bool> Is{state}Async();");
            sb.AppendLine();
        }
        
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private void GenerateGrainImplementation(StringBuilder sb, StateMachineDefinition definition)
    {
        var stateName = $"{definition.Name}State";
        var triggerName = $"{definition.Name}Trigger";
        
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Grain implementation for {definition.Name} state machine");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public class {definition.Name}Grain : StateMachineGrain<{stateName}, {triggerName}>, I{definition.Name}Grain");
        sb.AppendLine("    {");
        
        // BuildStateMachine method
        sb.AppendLine($"        protected override StateMachine<{stateName}, {triggerName}> BuildStateMachine()");
        sb.AppendLine("        {");
        sb.AppendLine($"            var machine = new StateMachine<{stateName}, {triggerName}>({stateName}.{definition.InitialState ?? definition.States.First()});");
        sb.AppendLine();
        
        // Generate transitions
        if (definition.Transitions != null)
        {
            var stateGroups = definition.Transitions.GroupBy(t => t.From);
            foreach (var stateGroup in stateGroups)
            {
                sb.AppendLine($"            machine.Configure({stateName}.{stateGroup.Key})");
                
                foreach (var transition in stateGroup)
                {
                    if (!string.IsNullOrEmpty(transition.Guard))
                    {
                        sb.AppendLine($"                .PermitIf({triggerName}.{transition.Trigger}, {stateName}.{transition.To}, () => Check{transition.Guard}())");
                    }
                    else
                    {
                        sb.AppendLine($"                .Permit({triggerName}.{transition.Trigger}, {stateName}.{transition.To})");
                    }
                    
                    if (transition == stateGroup.Last())
                        sb.AppendLine(";");
                    else
                        sb.Append("");
                }
                sb.AppendLine();
            }
        }
        
        sb.AppendLine("            return machine;");
        sb.AppendLine("        }");
        sb.AppendLine();
        
        // Generate typed trigger methods
        foreach (var trigger in definition.Triggers)
        {
            sb.AppendLine($"        public Task Fire{trigger}Async()");
            sb.AppendLine("        {");
            sb.AppendLine($"            return FireAsync({triggerName}.{trigger});");
            sb.AppendLine("        }");
            sb.AppendLine();
        }
        
        // Generate state check methods
        foreach (var state in definition.States)
        {
            sb.AppendLine($"        public Task<bool> Is{state}Async()");
            sb.AppendLine("        {");
            sb.AppendLine($"            return IsInStateAsync({stateName}.{state});");
            sb.AppendLine("        }");
            sb.AppendLine();
        }
        
        // Generate guard methods if needed
        if (definition.Transitions != null)
        {
            var guards = definition.Transitions
                .Where(t => !string.IsNullOrEmpty(t.Guard))
                .Select(t => t.Guard)
                .Distinct();
                
            foreach (var guard in guards)
            {
                sb.AppendLine($"        private bool Check{guard}()");
                sb.AppendLine("        {");
                sb.AppendLine($"            // TODO: Implement {guard} guard logic");
                sb.AppendLine("            return true;");
                sb.AppendLine("        }");
                sb.AppendLine();
            }
        }
        
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private void GenerateHelperExtensions(StringBuilder sb, StateMachineDefinition definition)
    {
        var stateName = $"{definition.Name}State";
        var triggerName = $"{definition.Name}Trigger";
        
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Extension methods for {definition.Name} state machine");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static class {definition.Name}Extensions");
        sb.AppendLine("    {");
        
        // IsTerminal extension
        sb.AppendLine($"        /// <summary>");
        sb.AppendLine($"        /// Checks if the state is a terminal state");
        sb.AppendLine($"        /// </summary>");
        sb.AppendLine($"        public static bool IsTerminal(this {stateName} state)");
        sb.AppendLine("        {");
        sb.AppendLine("            return state switch");
        sb.AppendLine("            {");
        
        if (definition.TerminalStates != null)
        {
            foreach (var terminal in definition.TerminalStates)
            {
                sb.AppendLine($"                {stateName}.{terminal} => true,");
            }
        }
        
        sb.AppendLine("                _ => false");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
        sb.AppendLine();
        
        // GetDescription extension
        sb.AppendLine($"        /// <summary>");
        sb.AppendLine($"        /// Gets a human-readable description of the state");
        sb.AppendLine($"        /// </summary>");
        sb.AppendLine($"        public static string GetDescription(this {stateName} state)");
        sb.AppendLine("        {");
        sb.AppendLine("            return state switch");
        sb.AppendLine("            {");
        
        foreach (var state in definition.States)
        {
            sb.AppendLine($"                {stateName}.{state} => \"{ToSentenceCase(state)}\",");
        }
        
        sb.AppendLine($"                _ => state.ToString()");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
        
        sb.AppendLine("    }");
    }

    private string ToSentenceCase(string input)
    {
        if (string.IsNullOrEmpty(input))
            return input;
            
        var result = new StringBuilder();
        result.Append(char.ToUpper(input[0]));
        
        for (int i = 1; i < input.Length; i++)
        {
            if (char.IsUpper(input[i]))
            {
                result.Append(' ');
                result.Append(char.ToLower(input[i]));
            }
            else
            {
                result.Append(input[i]);
            }
        }
        
        return result.ToString();
    }
}

/// <summary>
/// Represents the complete definition of a state machine parsed from YAML or JSON.
/// </summary>
public class StateMachineDefinition
{
    /// <summary>
    /// Gets or sets the name of the state machine class to generate.
    /// </summary>
    public string Name { get; set; } = "";

    /// <summary>
    /// Gets or sets the namespace for the generated state machine class.
    /// </summary>
    public string? Namespace { get; set; }

    /// <summary>
    /// Gets or sets the description of the state machine's purpose.
    /// </summary>
    public string? Description { get; set; }

    /// <summary>
    /// Gets or sets the list of all possible states in the state machine.
    /// </summary>
    public List<string> States { get; set; } = [];

    /// <summary>
    /// Gets or sets the list of all possible triggers that can cause state transitions.
    /// </summary>
    public List<string> Triggers { get; set; } = [];

    /// <summary>
    /// Gets or sets the initial state of the state machine.
    /// </summary>
    public string? InitialState { get; set; }

    /// <summary>
    /// Gets or sets the list of terminal (final) states from which no transitions are possible.
    /// </summary>
    public List<string>? TerminalStates { get; set; }

    /// <summary>
    /// Gets or sets the list of transitions between states.
    /// </summary>
    public List<TransitionDefinition>? Transitions { get; set; }
}

/// <summary>
/// Represents a single state transition definition in the state machine.
/// </summary>
public class TransitionDefinition
{
    /// <summary>
    /// Gets or sets the source state of the transition.
    /// </summary>
    public string From { get; set; } = "";

    /// <summary>
    /// Gets or sets the destination state of the transition.
    /// </summary>
    public string To { get; set; } = "";

    /// <summary>
    /// Gets or sets the trigger that causes this transition.
    /// </summary>
    public string Trigger { get; set; } = "";

    /// <summary>
    /// Gets or sets the optional guard condition that must be satisfied for the transition to occur.
    /// </summary>
    public string? Guard { get; set; }

    /// <summary>
    /// Gets or sets the optional action to execute when the transition occurs.
    /// </summary>
    public string? Action { get; set; }
}